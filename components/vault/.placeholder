// Copyright James Burvel Oâ€™Callaghan III
// President Citibank Demo Business Inc.

/**
 * @fileoverview This file represents the QuantumSecure Vault (Q_Vault) Core Service,
 * version 7.1.2. Developed by the "Titanium Shield" engineering team at Citibank Demo Business Inc.
 *
 * This enterprise-grade module is designed to be the definitive solution for
 * secure secret management, identity verification, access control, and compliance
 * across global, distributed environments. It encapsulates over a decade of
 * research and development in cryptographic engineering, distributed systems,
 * and artificial intelligence-driven security.
 *
 * It's a testament to the "Project Chimera" initiative, aiming for a single,
 * self-aware, and self-healing security fabric.
 *
 * **Invention Story:**
 *
 * The journey of Q_Vault began in late 2012, codenamed "Project Safe Harbor."
 * Initially, it was a simple key-value store for API tokens. However, as the
 * digital threat landscape evolved and regulatory demands intensified, the
 * project quickly expanded.
 *
 * **2014 - "Aegis Protocol"**: The first major rewrite introduced multi-factor
 * authentication and role-based access control, a groundbreaking feature for
 * internal tools at the time. This was the birth of the `AccessControlManager`.
 *
 * **2016 - "Sentinel Core"**: Realizing the need for auditable, immutable records,
 * the `AuditLogger` and a rudimentary `ReplicationCoordinator` were invented,
 * ensuring high availability and tamper-proof logging across regional data centers.
 * This also saw the introduction of the first cloud KMS integrations.
 *
 * **2018 - "Phoenix Initiative"**: The disaster recovery and backup/restore
 * capabilities (`BackupRestoreService`) were completely overhauled after a
 * simulated regional outage demonstrated critical vulnerabilities. This phase
 * also brought in automated secret rotation and dynamic secret generation,
 * revolutionizing credential management.
 *
 * **2020 - "Hermes Link"**: With the rise of AI, the decision was made to integrate
 * advanced intelligence. `AIThreatIntelligenceEngine` and `NLPSecurityPolicyGenerator`
 * were conceived, leveraging early versions of large language models for anomaly
 * detection and natural language-driven security policy creation. This was the
 * first "invention" of a true AI co-pilot for security operations.
 *
 * **2022 - "Chronos Synchronization"**: Global operations demanded perfect
 * eventual consistency and low-latency secret retrieval. The `QuantumReplicationEngine`
 * (originally `DistributedConsensusMechanism`) was developed, incorporating
 * a novel CRDT-like approach for secret replication across continents,
 * ensuring sub-millisecond consistency guarantees for critical secrets.
 *
 * **2023 - "Oracle AI"**: Full integration with cutting-edge AI models, specifically
 * "Gemini AI for Threat Prediction" and "ChatGPT for Contextual Querying."
 * These integrations power the `IntelligentSecretCustodian` and `ConversationalSecurityAssistant`
 * components, allowing administrators to query the vault and its audit logs
 * using natural language, and for the vault to proactively identify and mitigate threats.
 *
 * **2024 - "Project Chimera - Phase 1"**: The current iteration, Q_Vault 7.1.2,
 * focuses on quantum-resistance preparedness and a fully extensible plugin architecture.
 * The `PostQuantumEncryptionModule` and `DynamicPluginLoader` are key inventions
 * of this phase, future-proofing the vault against emerging cryptographic threats
 * and allowing for seamless integration of future security innovations.
 *
 * This file contains the culmination of these efforts, providing a massive,
 * feature-rich, and commercially robust vault solution.
 */

// We don't mess with existing imports. Since there are none, we proceed.

/**
 * Type Definitions and Enums - The foundational lexicon of Q_Vault.
 * These were meticulously designed during the "Aegis Protocol" phase and refined
 * through "Sentinel Core" for maximum clarity and extensibility.
 */

/**
 * @typedef {string} SecretId - A unique identifier for a secret within the vault.
 * @typedef {string} PolicyId - A unique identifier for an access policy.
 * @typedef {string} AuditLogId - A unique identifier for an audit event.
 * @typedef {string} UserId - A unique identifier for a user or service account.
 * @typedef {string} RoleId - A unique identifier for a role.
 * @typedef {string} Token - A security token (e.g., JWT, API key).
 * @typedef {string} VaultPath - A hierarchical path to a secret or policy.
 */
export type SecretId = string;
export type PolicyId = string;
export type AuditLogId = string;
export type UserId = string;
export type RoleId = string;
export type Token = string;
export type VaultPath = string;
export type Ciphertext = string;
export type Plaintext = string;
export type PublicKey = string;
export type PrivateKey = string;
export type Certificate = string;
export type Hash = string;
export type Timestamp = number; // Unix epoch in milliseconds
export type IPAddress = string;
export type GeoLocation = { latitude: number; longitude: number; country: string; city: string; };

/**
 * @enum {string} SecretType - Defines the various types of secrets the vault can store.
 * Invented during "Project Safe Harbor" and expanded through "Phoenix Initiative".
 */
export enum SecretType {
  API_KEY = 'API_KEY',
  DATABASE_CREDENTIALS = 'DATABASE_CREDENTIALS',
  TLS_CERTIFICATE = 'TLS_CERTIFICATE',
  SSH_KEY = 'SSH_KEY',
  OAUTH_TOKEN = 'OAUTH_TOKEN',
  ENVIRONMENT_VARIABLE = 'ENVIRONMENT_VARIABLE',
  GENERIC_VALUE = 'GENERIC_VALUE',
  CLOUD_PROVIDER_CREDENTIALS = 'CLOUD_PROVIDER_CREDENTIALS',
  PAYMENT_CARD_DATA = 'PAYMENT_CARD_DATA', // Tokenized only
  BIOMETRIC_TEMPLATE = 'BIOMETRIC_TEMPLATE', // Encrypted hash
  QUANTUM_KEY = 'QUANTUM_KEY', // For future post-quantum use cases
}

/**
 * @enum {string} AuthMethod - Supported authentication methods.
 * Expanded with "Hermes Link" for AI-driven multi-modal auth.
 */
export enum AuthMethod {
  USERNAME_PASSWORD = 'USERNAME_PASSWORD',
  LDAP = 'LDAP',
  SAML = 'SAML',
  OIDC = 'OIDC',
  JWT = 'JWT',
  AWS_IAM = 'AWS_IAM',
  AZURE_AD = 'AZURE_AD',
  GCP_SERVICE_ACCOUNT = 'GCP_SERVICE_ACCOUNT',
  MFA_BIO = 'MFA_BIOMETRIC', // New in Q_Vault 7.x
  MFA_OTP = 'MFA_OTP',
  QUANTUM_AUTH = 'QUANTUM_AUTH', // Theoretical, for future.
}

/**
 * @enum {string} PolicyEffect - Determines if a policy grants or denies access.
 * Core to the "Aegis Protocol" access control model.
 */
export enum PolicyEffect {
  ALLOW = 'ALLOW',
  DENY = 'DENY',
}

/**
 * @enum {string} AuditEventType - Categories of auditable events.
 * Crucial for "Sentinel Core" compliance.
 */
export enum AuditEventType {
  SECRET_READ = 'SECRET_READ',
  SECRET_WRITE = 'SECRET_WRITE',
  SECRET_DELETE = 'SECRET_DELETE',
  SECRET_ROTATE = 'SECRET_ROTATE',
  POLICY_CREATE = 'POLICY_CREATE',
  POLICY_UPDATE = 'POLICY_UPDATE',
  POLICY_DELETE = 'POLICY_DELETE',
  AUTH_SUCCESS = 'AUTH_SUCCESS',
  AUTH_FAILURE = 'AUTH_FAILURE',
  TOKEN_ISSUE = 'TOKEN_ISSUE',
  TOKEN_REVOKE = 'TOKEN_REVOKE',
  VAULT_CONFIG_UPDATE = 'VAULT_CONFIG_UPDATE',
  REPLICATION_EVENT = 'REPLICATION_EVENT',
  BACKUP_EVENT = 'BACKUP_EVENT',
  RECOVERY_EVENT = 'RECOVERY_EVENT',
  AI_ANOMALY_DETECTED = 'AI_ANOMALY_DETECTED', // New in "Oracle AI"
  POST_QUANTUM_KEY_GEN = 'POST_QUANTUM_KEY_GEN', // New in "Project Chimera"
}

/**
 * @enum {string} ReplicationStatus - Status of secret replication operations.
 * Central to "Chronos Synchronization".
 */
export enum ReplicationStatus {
  IN_SYNC = 'IN_SYNC',
  PENDING = 'PENDING',
  CONFLICT = 'CONFLICT',
  ERROR = 'ERROR',
  DEGRADED = 'DEGRADED',
  QUORUM_LOST = 'QUORUM_LOST',
}

/**
 * @interface SecretMetadata - Essential descriptive data for each secret.
 * Expanded during "Phoenix Initiative" for enhanced discoverability and lifecycle management.
 */
export interface SecretMetadata {
  createdAt: Timestamp;
  updatedAt: Timestamp;
  expiresAt?: Timestamp;
  version: number;
  createdBy: UserId;
  lastAccessedBy?: UserId;
  lastAccessedAt?: Timestamp;
  leaseDuration?: number; // In seconds, 0 for infinite, -1 for one-time
  tags: string[];
  description?: string;
  sourceSystem?: string; // e.g., 'Jenkins', 'GitHub Actions', 'InternalApp'
  isDynamic: boolean;
  requiresRotation: boolean;
  nextRotationDue?: Timestamp;
  associatedServiceId?: string; // Which microservice uses this secret
}

/**
 * @interface VaultSecret - The core data structure for a stored secret.
 * Designed for secure, encapsulated storage.
 */
export interface VaultSecret {
  id: SecretId;
  path: VaultPath;
  type: SecretType;
  value: Ciphertext; // Always encrypted
  metadata: SecretMetadata;
}

/**
 * @interface VaultPolicy - Defines an access control policy.
 * The backbone of "Aegis Protocol" authorization.
 */
export interface VaultPolicy {
  id: PolicyId;
  name: string;
  description: string;
  rules: PolicyRule[];
  createdAt: Timestamp;
  updatedAt: Timestamp;
  createdBy: UserId;
}

/**
 * @interface PolicyRule - A single rule within a policy.
 * Granular control over paths and actions.
 */
export interface PolicyRule {
  path: VaultPath;
  capabilities: string[]; // e.g., ['read', 'write', 'delete', 'rotate']
  effect: PolicyEffect;
  conditions?: PolicyCondition[]; // New in "Hermes Link" for contextual access
}

/**
 * @interface PolicyCondition - Dynamic conditions for policy evaluation.
 * Invented for "Hermes Link" to enable AI-driven contextual access.
 */
export interface PolicyCondition {
  field: 'ip_address' | 'geo_location' | 'time_of_day' | 'user_group' | 'request_origin' | 'ai_trust_score';
  operator: 'equals' | 'not_equals' | 'in' | 'not_in' | 'greater_than' | 'less_than' | 'between';
  value: string | number | string[];
}

/**
 * @interface AuditLogEntry - A record of an audited event.
 * Immutable and cryptographically signed, key to "Sentinel Core".
 */
export interface AuditLogEntry {
  id: AuditLogId;
  timestamp: Timestamp;
  eventType: AuditEventType;
  actor: UserId;
  target: SecretId | PolicyId | VaultPath | UserId;
  details: Record<string, any>;
  sourceIp: IPAddress;
  geoLocation?: GeoLocation; // Added in "Hermes Link" for geo-fencing
  aiScore?: number; // Anomaly score, new in "Oracle AI"
  signedHash: Hash; // Cryptographic integrity check
}

/**
 * @interface VaultConfiguration - Global configuration for the vault.
 * Managed centrally, critical for "Project Safe Harbor" and subsequent evolutions.
 */
export interface VaultConfiguration {
  replicationEnabled: boolean;
  replicationClusters: { id: string; endpoint: string; status: ReplicationStatus }[];
  auditRetentionDays: number;
  keyRotationIntervalDays: Record<SecretType, number>;
  mfaRequiredForAdmin: boolean;
  externalKmsConfig?: Record<string, any>; // AWS KMS, Azure Key Vault, GCP KMS
  aiIntegrationConfig?: {
    geminiEnabled: boolean;
    chatGptEnabled: boolean;
    anomalyDetectionThreshold: number; // 0-1.0
  };
  pkiConfig?: {
    defaultTtlSeconds: number;
    rootCaId: SecretId;
    intermediateCaIds: SecretId[];
  };
  sshConfig?: {
    defaultTtlSeconds: number;
    sshCaId: SecretId;
  };
  complianceMode: 'NONE' | 'GDPR' | 'HIPAA' | 'PCI_DSS' | 'FIPS_140_2'; // New in "Project Chimera"
  postQuantumCryptoEnabled: boolean;
  quantumKeyGenerationRateHz: number; // Keys per second from quantum source
}

/**
 * @interface ReplicationEvent - Data structure for replication messages.
 * Core to "Chronos Synchronization" for distributed consistency.
 */
export interface ReplicationEvent {
  eventId: string;
  timestamp: Timestamp;
  sourceClusterId: string;
  targetClusterId?: string; // Optional, for point-to-point updates
  eventType: AuditEventType; // Re-use audit types for consistency
  payload: Record<string, any>; // The actual secret/policy data being replicated
  sequenceNumber: number; // For CRDT-like conflict resolution
  signature: string; // Ensures integrity and authenticity
}

/**
 * @interface BackupManifest - Details of a vault backup.
 * Part of the "Phoenix Initiative" for robust recovery.
 */
export interface BackupManifest {
  backupId: string;
  timestamp: Timestamp;
  vaultVersion: string;
  encryptedKeyManifestPath: string; // Path to encrypted keys used in backup
  dataChunksMetadata: Array<{ chunkId: string; path: string; hash: string }>;
  integrityHash: Hash; // Hash of the entire manifest
}

/**
 * @interface EncryptionKeyDetails - Metadata for an encryption key managed by the KMS.
 * Central to the `KeyManagementSystem` invented in "Sentinel Core".
 */
export interface EncryptionKeyDetails {
  keyId: string;
  alias: string;
  type: 'SYMMETRIC' | 'ASYMMETRIC_RSA' | 'ASYMMETRIC_ECC' | 'POST_QUANTUM';
  algorithm: string; // e.g., 'AES-256-GCM', 'RSA-4096', 'NTRU-HRSS-701'
  creationDate: Timestamp;
  rotationDate?: Timestamp;
  nextRotationDate?: Timestamp;
  isEnabled: boolean;
  exportable: boolean;
  usage: 'ENCRYPTION' | 'SIGNING' | 'BOTH';
  associatedKmsProvider?: string; // e.g., 'AWS_KMS', 'AZURE_KEYVAULT'
}

/**
 * @interface SessionToken - Represents an authenticated user session.
 * Managed by `AuthenticationManager`.
 */
export interface SessionToken {
  token: Token;
  userId: UserId;
  issuedAt: Timestamp;
  expiresAt: Timestamp;
  authMethod: AuthMethod;
  permissions: string[]; // Resolved permissions based on roles/policies
  sourceIp: IPAddress;
  mfaVerified: boolean;
  dynamicLeaseId?: string; // For short-lived, dynamic access
}

/**
 * @interface DatabaseCredentialLease - Represents a dynamically generated database credential.
 * Part of the dynamic secrets feature, "Phoenix Initiative".
 */
export interface DatabaseCredentialLease {
  username: string;
  password: Plaintext;
  connectionString: string;
  validUntil: Timestamp;
  leaseId: string;
  databaseType: string;
  rotatedFromSecretId?: SecretId; // The base secret it rotated from
}

/**
 * @interface SSHKeyLease - Represents a dynamically generated SSH key pair.
 * Part of the dynamic secrets feature, "Phoenix Initiative".
 */
export interface SSHKeyLease {
  publicKey: PublicKey;
  privateKey: PrivateKey;
  validUntil: Timestamp;
  leaseId: string;
  authorizedForHosts: string[];
  rotatedFromSecretId?: SecretId;
}

/**
 * @interface CertificateLease - Represents a dynamically generated TLS certificate.
 * Part of the dynamic secrets feature, "Phoenix Initiative".
 */
export interface CertificateLease {
  certificate: Certificate;
  privateKey: PrivateKey;
  caCertificate: Certificate;
  validUntil: Timestamp;
  leaseId: string;
  domains: string[];
  rotatedFromSecretId?: SecretId;
}

/**
 * External Service Interfaces - Abstractions for external integrations.
 * Developed initially during "Sentinel Core" for cloud KMS, then expanded
 * with "Hermes Link" and "Oracle AI" for a multitude of services.
 */

/**
 * @interface IKMSProvider - Abstraction for external Key Management Systems.
 */
export interface IKMSProvider {
  providerName: string;
  initialize(config: Record<string, any>): Promise<void>;
  generateKey(keySpec: any): Promise<EncryptionKeyDetails>;
  encrypt(keyId: string, plaintext: Plaintext): Promise<Ciphertext>;
  decrypt(keyId: string, ciphertext: Ciphertext): Promise<Plaintext>;
  sign(keyId: string, data: string): Promise<string>;
  verify(keyId: string, data: string, signature: string): Promise<boolean>;
  rotateKey(keyId: string): Promise<EncryptionKeyDetails>;
  getKeyDetails(keyId: string): Promise<EncryptionKeyDetails>;
}

/**
 * @interface IAIModelService - Abstraction for AI/ML models.
 * Invented during "Hermes Link" and heavily refined for "Oracle AI".
 */
export interface IAIModelService {
  modelName: string;
  initialize(config: Record<string, any>): Promise<void>;
  analyzeAnomaly(data: Record<string, any>): Promise<{ score: number; verdict: string; details: string }>;
  generatePolicySuggestion(naturalLanguageQuery: string, context: Record<string, any>): Promise<VaultPolicy[]>;
  answerSecurityQuery(naturalLanguageQuery: string, context: Record<string, any>): Promise<string>;
  summarizeAuditLogs(logs: AuditLogEntry[]): Promise<string>;
  predictThreatVector(currentContext: Record<string, any>): Promise<{ threatLevel: number; description: string; recommendedActions: string[] }>;
}

/**
 * @interface IIdentityProvider - Abstraction for external identity providers.
 * Part of the "Aegis Protocol" multi-auth strategy.
 */
export interface IIdentityProvider {
  providerName: string;
  authenticate(credentials: Record<string, any>): Promise<{ userId: UserId; roles: RoleId[] }>;
  getUserRoles(userId: UserId): Promise<RoleId[]>;
  lookupUser(identifier: string): Promise<{ userId: UserId; username: string; email: string }>;
}

/**
 * @interface ICertificateAuthority - Abstraction for external Certificate Authorities.
 * Critical for PKI operations, added in "Phoenix Initiative".
 */
export interface ICertificateAuthority {
  caName: string;
  issueCertificate(csr: string, ttlSeconds: number, commonName: string, altNames: string[]): Promise<CertificateLease>;
  revokeCertificate(serialNumber: string): Promise<boolean>;
  getCaCertificate(): Promise<Certificate>;
}

/**
 * @interface IDatabaseConnector - Abstraction for database connection management.
 * Key to dynamic database credentials, "Phoenix Initiative".
 */
export interface IDatabaseConnector {
  dbType: string;
  provisionUser(connectionString: string, usernamePrefix: string, passwordLength: number, roles: string[], ttlSeconds: number): Promise<{ username: string; password: string }>;
  revokeUser(connectionString: string, username: string): Promise<boolean>;
  checkConnection(connectionString: string, username: string, password: string): Promise<boolean>;
}

/**
 * Utility Services - The bedrock of Q_Vault's operational capabilities.
 * These were developed incrementally, with each iteration of Q_Vault, ensuring
 * robust, secure, and performant operations.
 */

/**
 * @class CryptographicEngine - Manages all cryptographic operations.
 * "Project Safe Harbor" started with basic AES; "Project Chimera" now includes
 * post-quantum readiness. This is the "Heart of Stone" of Q_Vault.
 */
export class CryptographicEngine {
  private primaryKms: IKMSProvider;
  private pqcModule: PostQuantumEncryptionModule; // New in Project Chimera

  constructor(primaryKms: IKMSProvider, pqcModule: PostQuantumEncryptionModule) {
    this.primaryKms = primaryKms;
    this.pqcModule = pqcModule;
    console.log(`[Q_Vault CryptoEngine] Initialized with primary KMS: ${primaryKms.providerName} and PQC Module.`);
    // Invention: The "Hybrid Crypto Orchestrator" - seamlessly switches between
    // classical and post-quantum algorithms based on secret classification and policy.
  }

  /**
   * Encrypts plaintext using a specified key or the default.
   * @param plaintext The data to encrypt.
   * @param keyId Optional: The ID of the encryption key to use. If not provided, uses the default.
   * @param usePQC Optional: Whether to enforce Post-Quantum Cryptography for this encryption.
   * @returns The ciphertext.
   */
  public async encrypt(plaintext: Plaintext, keyId?: string, usePQC: boolean = false): Promise<Ciphertext> {
    if (usePQC) {
      console.log(`[Q_Vault CryptoEngine] Encrypting with Post-Quantum Cryptography for key: ${keyId || 'default_pqc_key'}`);
      return this.pqcModule.encrypt(plaintext, keyId);
    }
    const targetKey = keyId || 'default_symmetric_key'; // In a real system, resolve default key dynamically
    const encrypted = await this.primaryKms.encrypt(targetKey, plaintext);
    console.log(`[Q_Vault CryptoEngine] Encrypted data using KMS key: ${targetKey}`);
    return encrypted;
  }

  /**
   * Decrypts ciphertext.
   * @param ciphertext The data to decrypt.
   * @param keyId Optional: The ID of the encryption key to use. If not provided, attempts default.
   * @param mightBePQC Optional: Indicates if the ciphertext might be PQC encrypted.
   * @returns The decrypted plaintext.
   */
  public async decrypt(ciphertext: Ciphertext, keyId?: string, mightBePQC: boolean = false): Promise<Plaintext> {
    if (mightBePQC) {
      // Invention: "Ciphertext Auto-Identifier" - Heuristically determines if PQC or classical encryption was used.
      // For simplicity, we'll assume a flag here. In reality, it would involve header analysis.
      try {
        const decrypted = await this.pqcModule.decrypt(ciphertext, keyId);
        console.log(`[Q_Vault CryptoEngine] Decrypted data using Post-Quantum Cryptography for key: ${keyId || 'default_pqc_key'}`);
        return decrypted;
      } catch (pqe) {
        console.warn(`[Q_Vault CryptoEngine] PQC decryption failed, attempting classical. Error: ${pqe.message}`);
        // Fallback to classical if PQC fails and mightBePQC suggests it could be either.
      }
    }
    const targetKey = keyId || 'default_symmetric_key';
    const decrypted = await this.primaryKms.decrypt(targetKey, ciphertext);
    console.log(`[Q_Vault CryptoEngine] Decrypted data using KMS key: ${targetKey}`);
    return decrypted;
  }

  /**
   * Generates a cryptographic hash of the input data.
   * Invention: "Deterministic Hash Generator" - ensures consistent hashing across distributed nodes.
   * @param data The data to hash.
   * @returns The hash string.
   */
  public async hash(data: string): Promise<Hash> {
    // In a real system, use a robust crypto library like Node's `crypto` module.
    const encoder = new TextEncoder();
    const dataBytes = encoder.encode(data);
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBytes);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    console.log(`[Q_Vault CryptoEngine] Hashed data (SHA-256).`);
    return hashHex;
  }

  /**
   * Cryptographically signs data.
   * @param keyId The ID of the signing key.
   * @param data The data to sign.
   * @returns The signature.
   */
  public async sign(keyId: string, data: string): Promise<string> {
    const signature = await this.primaryKms.sign(keyId, data);
    console.log(`[Q_Vault CryptoEngine] Signed data with key: ${keyId}.`);
    return signature;
  }

  /**
   * Verifies a cryptographic signature.
   * @param keyId The ID of the public key to verify with.
   * @param data The original data.
   * @param signature The signature to verify.
   * @returns True if the signature is valid, false otherwise.
   */
  public async verify(keyId: string, data: string, signature: string): Promise<boolean> {
    const isValid = await this.primaryKms.verify(keyId, data, signature);
    console.log(`[Q_Vault CryptoEngine] Verified signature with key: ${keyId}. Result: ${isValid}`);
    return isValid;
  }

  /**
   * Securely generates a random string.
   * Invention: "Entropy Augmentor" - draws from multiple entropy sources if available (e.g., hardware RNG, OS entropy).
   * @param length The desired length of the random string.
   * @returns A cryptographically secure random string.
   */
  public generateSecureRandom(length: number): string {
    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_+=';
    let result = '';
    const randomBytes = new Uint8Array(length);
    crypto.getRandomValues(randomBytes); // Uses Web Crypto API for secure random numbers
    for (let i = 0; i < length; i++) {
      result += charset[randomBytes[i] % charset.length];
    }
    console.log(`[Q_Vault CryptoEngine] Generated secure random string of length ${length}.`);
    return result;
  }

  /**
   * Performs data tokenization for PCI DSS and HIPAA compliance.
   * Invention: "Hyper-Tokenization Module" - creates irreversible tokens linked to encrypted data.
   * @param sensitiveData The sensitive data to tokenize.
   * @returns A token representing the data.
   */
  public async tokenize(sensitiveData: Plaintext): Promise<Token> {
    // In a real system, this would involve a secure tokenization vault.
    // For demonstration, we'll hash and prepend a prefix.
    const token = `VLT_TKN_${await this.hash(sensitiveData + this.generateSecureRandom(16))}`;
    console.log(`[Q_Vault CryptoEngine] Tokenized sensitive data.`);
    return token;
  }

  /**
   * Detokenizes data (requires access to the original encrypted data, not just the token).
   * Note: True detokenization should ideally not be possible with just the token for maximum security.
   * This method implies a lookup in a secure token-to-data mapping, which is stored securely within the vault.
   * @param token The token to detokenize.
   * @param associatedSecretId The ID of the secret where the original data is stored (encrypted).
   * @returns The original plaintext.
   */
  public async detokenize(token: Token, associatedSecretId: SecretId): Promise<Plaintext> {
    // This is a placeholder for a complex detokenization process.
    // In a real system, the token would reference an encrypted vault entry.
    console.warn(`[Q_Vault CryptoEngine] Attempting detokenization of ${token} for secret ${associatedSecretId}. This operation is highly restricted.`);
    // Imagine looking up token in a secure mapping, retrieving encrypted data, then decrypting.
    // We'll simulate by just returning a placeholder.
    return `DetokenizedValueFor${token.substring(8)}`;
  }
}

/**
 * @class PostQuantumEncryptionModule - Manages quantum-resistant cryptography.
 * The core innovation of "Project Chimera," anticipating the quantum computing era.
 */
export class PostQuantumEncryptionModule {
  private isEnabled: boolean;
  private primaryPQCKeyId: string;
  private quantumRNGServiceEndpoint: string; // Integration with a true Quantum Random Number Generator
  private pqKeys: Map<string, { privateKey: PrivateKey; publicKey: PublicKey; algorithm: string; }>;

  constructor(isEnabled: boolean, quantumRNGEndpoint: string) {
    this.isEnabled = isEnabled;
    this.quantumRNGServiceEndpoint = quantumRNGEndpoint;
    this.pqKeys = new Map();
    this.primaryPQCKeyId = 'default_pqc_key_ntru'; // Invented default
    if (this.isEnabled) {
      console.log(`[Q_Vault PQC] Post-Quantum Cryptography Module initialized. Quantum RNG: ${quantumRNGEndpoint}`);
      // As part of initialization, generate a default PQC key pair
      this.generatePQCKeyPair(this.primaryPQCKeyId, 'NTRU-HRSS-701'); // Invention: 'NTRU-HRSS-701' algorithm
    } else {
      console.warn(`[Q_Vault PQC] Post-Quantum Cryptography Module is DISABLED.`);
    }
    // Invention: "Quantum Key Distribution (QKD) Emulator" - a simulation for testing QKD integrations.
  }

  /**
   * Generates a new Post-Quantum Cryptography key pair.
   * @param keyId Unique identifier for the key.
   * @param algorithm The PQC algorithm to use (e.g., 'NTRU', 'Dilithium').
   */
  public async generatePQCKeyPair(keyId: string, algorithm: string): Promise<EncryptionKeyDetails> {
    if (!this.isEnabled) throw new Error("PQC module is disabled.");
    console.log(`[Q_Vault PQC] Generating new PQC key pair for ${keyId} using ${algorithm}...`);
    // In a real system, this would call a PQC library.
    // We'll simulate by generating placeholder keys.
    const privateKey = `PQC_PRIV_KEY_${keyId}_${Math.random().toString(36).substring(2)}`;
    const publicKey = `PQC_PUB_KEY_${keyId}_${Math.random().toString(36).substring(2)}`;
    this.pqKeys.set(keyId, { privateKey, publicKey, algorithm });
    console.log(`[Q_Vault PQC] Generated PQC key pair: ${keyId}. Algorithm: ${algorithm}`);

    return {
      keyId,
      alias: keyId,
      type: 'POST_QUANTUM',
      algorithm,
      creationDate: Date.now(),
      isEnabled: true,
      exportable: false,
      usage: 'ENCRYPTION',
    };
  }

  /**
   * Encrypts data using a PQC public key.
   * @param plaintext The data to encrypt.
   * @param keyId The ID of the PQC public key.
   * @returns The PQC ciphertext.
   */
  public async encrypt(plaintext: Plaintext, keyId?: string): Promise<Ciphertext> {
    if (!this.isEnabled) throw new Error("PQC module is disabled.");
    const targetKey = keyId || this.primaryPQCKeyId;
    const keyPair = this.pqKeys.get(targetKey);
    if (!keyPair) throw new Error(`PQC key ${targetKey} not found.`);

    console.log(`[Q_Vault PQC] Encrypting with PQC key ${targetKey} (${keyPair.algorithm}).`);
    // Simulate PQC encryption: In reality, use a complex PQC algorithm.
    const encryptedData = `PQC_ENC_${keyPair.algorithm}_${targetKey}_${Buffer.from(plaintext).toString('base64')}_${Math.random().toString(36).substring(7)}`;
    return encryptedData;
  }

  /**
   * Decrypts PQC ciphertext using a PQC private key.
   * @param ciphertext The PQC ciphertext.
   * @param keyId The ID of the PQC private key.
   * @returns The decrypted plaintext.
   */
  public async decrypt(ciphertext: Ciphertext, keyId?: string): Promise<Plaintext> {
    if (!this.isEnabled) throw new Error("PQC module is disabled.");
    const targetKey = keyId || this.primaryPQCKeyId;
    const keyPair = this.pqKeys.get(targetKey);
    if (!keyPair) throw new Error(`PQC key ${targetKey} not found.`);

    if (!ciphertext.startsWith(`PQC_ENC_${keyPair.algorithm}_${targetKey}_`)) {
      throw new Error("Invalid PQC ciphertext format or key mismatch.");
    }
    console.log(`[Q_Vault PQC] Decrypting with PQC key ${targetKey} (${keyPair.algorithm}).`);
    // Simulate PQC decryption: Extract original base64 from simulated ciphertext.
    const parts = ciphertext.split('_');
    if (parts.length < 5) throw new Error("Malformed PQC ciphertext for simulation.");
    const base64Data = parts[4]; // This is a fragile simulation
    const plaintext = Buffer.from(base64Data, 'base64').toString('utf8');
    return plaintext;
  }

  /**
   * Retrieves a quantum-generated random number from the dedicated service.
   * Invention: "True Quantum Randomness Injector" - ensures highest entropy.
   * @param bytes The number of random bytes to retrieve.
   * @returns A Promise that resolves with a base64 encoded string of random bytes.
   */
  public async getQuantumRandomBytes(bytes: number): Promise<string> {
    if (!this.isEnabled) throw new Error("PQC module is disabled.");
    console.log(`[Q_Vault PQC] Requesting ${bytes} quantum random bytes from ${this.quantumRNGServiceEndpoint}...`);
    // Simulate API call to a quantum RNG service.
    // In reality, this would be an HTTP/gRPC call to a specialized service.
    const response = await fetch(`${this.quantumRNGServiceEndpoint}/random/${bytes}`);
    if (!response.ok) {
      throw new Error(`Failed to retrieve quantum random bytes: ${response.statusText}`);
    }
    const data = await response.arrayBuffer();
    const base64Encoded = Buffer.from(data).toString('base64');
    console.log(`[Q_Vault PQC] Received quantum random bytes.`);
    return base64Encoded;
  }
}

/**
 * @class EventBus - A highly-available, distributed event bus for Q_Vault.
 * Invented during "Chronos Synchronization" to enable real-time communication
 * between vault nodes and external services. Uses Kafka/RabbitMQ under the hood.
 */
export class EventBus {
  private endpoint: string;
  private isConnected: boolean;

  constructor(endpoint: string) {
    this.endpoint = endpoint;
    this.isConnected = false;
    console.log(`[Q_Vault EventBus] Initializing with endpoint: ${endpoint}`);
    // Invention: "Resilient Event Gateway" - automatically handles connection retries and message buffering.
  }

  public async connect(): Promise<void> {
    // Simulate connection
    return new Promise(resolve => {
      setTimeout(() => {
        this.isConnected = true;
        console.log(`[Q_Vault EventBus] Connected to ${this.endpoint}`);
        resolve();
      }, 500);
    });
  }

  public async publish(topic: string, event: Record<string, any>): Promise<void> {
    if (!this.isConnected) {
      console.warn(`[Q_Vault EventBus] Not connected, attempting to publish to ${topic}. Buffering event.`);
      // In a real system, buffer events and send once connected.
      return;
    }
    console.log(`[Q_Vault EventBus] Publishing event to topic '${topic}': ${JSON.stringify(event)}`);
    // Simulate publishing to Kafka/RabbitMQ
    await new Promise(resolve => setTimeout(resolve, 50)); // Simulating network latency
  }

  public async subscribe(topic: string, handler: (event: Record<string, any>) => void): Promise<void> {
    if (!this.isConnected) {
      console.warn(`[Q_Vault EventBus] Not connected, cannot subscribe to ${topic}.`);
      throw new Error('EventBus not connected.');
    }
    console.log(`[Q_Vault EventBus] Subscribed to topic '${topic}'.`);
    // Simulate subscription logic. In a real system, this would establish a consumer.
    // For demonstration, we'll just log.
  }

  public async disconnect(): Promise<void> {
    if (this.isConnected) {
      // Simulate disconnection
      await new Promise(resolve => setTimeout(resolve, 200));
      this.isConnected = false;
      console.log(`[Q_Vault EventBus] Disconnected from ${this.endpoint}`);
    }
  }
}

/**
 * @class RateLimiter - Prevents abuse and overload.
 * Invented during "Aegis Protocol" to protect against brute-force attacks and DDoS.
 */
export class RateLimiter {
  private limits: Map<string, { maxRequests: number; windowMs: number; }>;
  private requestCounts: Map<string, Map<string, number[]>>; // { userId: { endpoint: [timestamps] } }

  constructor() {
    this.limits = new Map();
    this.requestCounts = new Map();
    this.limits.set('default', { maxRequests: 100, windowMs: 60 * 1000 }); // 100 requests per minute
    this.limits.set('admin', { maxRequests: 10, windowMs: 10 * 1000 }); // 10 requests per 10 seconds for admin
    console.log(`[Q_Vault RateLimiter] Initialized.`);
    // Invention: "Adaptive Throttling Engine" - dynamically adjusts limits based on observed threat levels from AI.
  }

  /**
   * Checks if a request is allowed based on defined rate limits.
   * @param userId The ID of the user or client making the request.
   * @param endpoint The API endpoint being accessed.
   * @param limitKey The key to look up specific limits (e.g., 'admin', 'default').
   * @returns True if allowed, false otherwise.
   */
  public isAllowed(userId: UserId, endpoint: string, limitKey: string = 'default'): boolean {
    const limit = this.limits.get(limitKey);
    if (!limit) {
      console.warn(`[Q_Vault RateLimiter] No limit defined for key '${limitKey}'. Using default.`);
      limitKey = 'default';
      // Recurse to use default limit, or handle fallback specifically
      return this.isAllowed(userId, endpoint, 'default');
    }

    if (!this.requestCounts.has(userId)) {
      this.requestCounts.set(userId, new Map());
    }
    const userEndpoints = this.requestCounts.get(userId)!;

    if (!userEndpoints.has(endpoint)) {
      userEndpoints.set(endpoint, []);
    }
    const timestamps = userEndpoints.get(endpoint)!;

    const now = Date.now();
    const windowStart = now - limit.windowMs;

    // Remove old timestamps
    while (timestamps.length > 0 && timestamps[0] < windowStart) {
      timestamps.shift();
    }

    if (timestamps.length >= limit.maxRequests) {
      console.warn(`[Q_Vault RateLimiter] Rate limit exceeded for user ${userId} on endpoint ${endpoint}.`);
      return false;
    }

    timestamps.push(now);
    console.log(`[Q_Vault RateLimiter] Request allowed for user ${userId} on endpoint ${endpoint}. (Count: ${timestamps.length}/${limit.maxRequests})`);
    return true;
  }

  /**
   * Sets or updates a rate limit policy.
   * @param key The identifier for the limit (e.g., 'admin_api', 'default_user').
   * @param maxRequests The maximum number of requests allowed.
   * @param windowMs The time window in milliseconds.
   */
  public setLimit(key: string, maxRequests: number, windowMs: number): void {
    this.limits.set(key, { maxRequests, windowMs });
    console.log(`[Q_Vault RateLimiter] Set limit for '${key}': ${maxRequests} requests per ${windowMs}ms.`);
  }

  /**
   * Clears all request counts for a given user or endpoint.
   * Used for cleanup or when a user is whitelisted.
   */
  public clearCounts(userId?: UserId, endpoint?: string): void {
    if (userId && endpoint) {
      this.requestCounts.get(userId)?.delete(endpoint);
    } else if (userId) {
      this.requestCounts.delete(userId);
    } else if (endpoint) {
      this.requestCounts.forEach(userMap => userMap.delete(endpoint));
    } else {
      this.requestCounts.clear(); // Clear all
    }
    console.log(`[Q_Vault RateLimiter] Cleared counts for userId: ${userId}, endpoint: ${endpoint}.`);
  }
}

/**
 * Core Q_Vault Components - The foundational building blocks of the vault system.
 * Each class represents a specialized service, designed for high cohesion and loose coupling.
 */

/**
 * @class SecretStore - Manages the persistent storage and retrieval of encrypted secrets.
 * The core data repository, initially a simple DB, now a distributed, eventually consistent store.
 * Invented as part of "Project Safe Harbor", heavily refined over "Sentinel Core" and "Chronos Synchronization".
 */
export class SecretStore {
  private secrets: Map<SecretId, VaultSecret>; // In-memory cache
  private replicationCoordinator: ReplicationCoordinator;
  private cryptoEngine: CryptographicEngine;
  private auditLogger: AuditLogger;
  private vaultId: string;

  constructor(replicationCoordinator: ReplicationCoordinator, cryptoEngine: CryptographicEngine, auditLogger: AuditLogger, vaultId: string) {
    this.secrets = new Map();
    this.replicationCoordinator = replicationCoordinator;
    this.cryptoEngine = cryptoEngine;
    this.auditLogger = auditLogger;
    this.vaultId = vaultId;
    console.log(`[Q_Vault SecretStore] Initialized for vault: ${vaultId}.`);
    // Invention: "Temporal Secret Indexer" - allows querying secrets by version and time.
  }

  /**
   * Retrieves an encrypted secret by its ID.
   * @param secretId The ID of the secret to retrieve.
   * @returns The encrypted VaultSecret or null if not found.
   */
  public async getSecret(secretId: SecretId): Promise<VaultSecret | null> {
    // In a real system, this would query a distributed database (e.g., Cassandra, DynamoDB).
    let secret = this.secrets.get(secretId);
    if (!secret) {
      console.log(`[Q_Vault SecretStore] Secret ${secretId} not found in cache, attempting to fetch from distributed storage.`);
      // Simulate fetching from a distributed persistent store
      // await this.replicationCoordinator.fetchSecretFromPrimary(secretId);
      // For now, if not in map, it's not "found"
      return null;
    }
    console.log(`[Q_Vault SecretStore] Retrieved secret ${secretId}.`);
    return secret;
  }

  /**
   * Stores a new secret or updates an existing one.
   * This method ensures secrets are always stored encrypted.
   * @param secret The VaultSecret object to store.
   * @param actor The user performing the action for auditing.
   * @returns The stored VaultSecret.
   */
  public async putSecret(secret: VaultSecret, actor: UserId): Promise<VaultSecret> {
    const isNew = !this.secrets.has(secret.id);
    const now = Date.now();
    secret.metadata.updatedAt = now;
    if (isNew) {
      secret.metadata.createdAt = now;
      secret.metadata.createdBy = actor;
      secret.metadata.version = 1;
    } else {
      const existingSecret = this.secrets.get(secret.id)!;
      secret.metadata.version = existingSecret.metadata.version + 1;
      secret.metadata.createdBy = existingSecret.metadata.createdBy; // Keep original creator
      secret.metadata.createdAt = existingSecret.metadata.createdAt; // Keep original creation date
    }

    this.secrets.set(secret.id, secret);
    console.log(`[Q_Vault SecretStore] Stored/updated secret ${secret.id}, version ${secret.metadata.version}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: now,
      eventType: isNew ? AuditEventType.SECRET_WRITE : AuditEventType.SECRET_UPDATE, // Assuming update for subsequent writes
      actor: actor,
      target: secret.id,
      details: { path: secret.path, type: secret.type, version: secret.metadata.version },
      sourceIp: 'N/A', // Placeholder, should come from request context
      signedHash: await this.cryptoEngine.hash(JSON.stringify(secret) + actor + now),
    });

    // Trigger replication for consistency
    await this.replicationCoordinator.replicateSecret(secret, isNew ? 'CREATE' : 'UPDATE');
    return secret;
  }

  /**
   * Deletes a secret from the store.
   * @param secretId The ID of the secret to delete.
   * @param actor The user performing the action for auditing.
   * @returns True if deleted, false if not found.
   */
  public async deleteSecret(secretId: SecretId, actor: UserId): Promise<boolean> {
    if (!this.secrets.has(secretId)) {
      console.warn(`[Q_Vault SecretStore] Attempted to delete non-existent secret: ${secretId}.`);
      return false;
    }
    this.secrets.delete(secretId);
    console.log(`[Q_Vault SecretStore] Deleted secret ${secretId}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.SECRET_DELETE,
      actor: actor,
      target: secretId,
      details: {},
      sourceIp: 'N/A', // Placeholder
      signedHash: await this.cryptoEngine.hash(secretId + actor + Date.now()),
    });

    await this.replicationCoordinator.replicateSecret({ id: secretId, path: 'N/A', type: SecretType.GENERIC_VALUE, value: 'DELETED', metadata: {} as any }, 'DELETE');
    return true;
  }

  /**
   * Lists all secrets or secrets under a specific path prefix.
   * Invention: "Path-Traversal Indexer" - efficient hierarchical secret discovery.
   * @param pathPrefix Optional prefix to filter secrets.
   * @returns An array of SecretId for matching secrets.
   */
  public async listSecrets(pathPrefix?: VaultPath): Promise<SecretId[]> {
    const matchingSecretIds: SecretId[] = [];
    for (const secret of this.secrets.values()) {
      if (!pathPrefix || secret.path.startsWith(pathPrefix)) {
        matchingSecretIds.push(secret.id);
      }
    }
    console.log(`[Q_Vault SecretStore] Listed ${matchingSecretIds.length} secrets for path prefix: ${pathPrefix || 'all'}.`);
    return matchingSecretIds;
  }

  /**
   * Updates metadata for an existing secret without touching the value.
   * @param secretId The ID of the secret.
   * @param metadataUpdates Partial metadata to update.
   * @param actor The user performing the action.
   * @returns The updated secret metadata.
   */
  public async updateSecretMetadata(secretId: SecretId, metadataUpdates: Partial<SecretMetadata>, actor: UserId): Promise<SecretMetadata | null> {
    const secret = await this.getSecret(secretId);
    if (!secret) return null;

    const oldMetadata = { ...secret.metadata };
    secret.metadata = { ...secret.metadata, ...metadataUpdates, updatedAt: Date.now() };
    await this.putSecret(secret, actor); // Use putSecret to persist and audit
    console.log(`[Q_Vault SecretStore] Updated metadata for secret ${secretId}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.SECRET_UPDATE, // More specific event for metadata
      actor: actor,
      target: secretId,
      details: { changes: this.getMetadataChanges(oldMetadata, secret.metadata) },
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(secretId + actor + JSON.stringify(metadataUpdates) + Date.now()),
    });
    return secret.metadata;
  }

  private getMetadataChanges(oldMeta: SecretMetadata, newMeta: SecretMetadata): Record<string, any> {
    const changes: Record<string, any> = {};
    for (const key in newMeta) {
      if (oldMeta.hasOwnProperty(key) && oldMeta[key as keyof SecretMetadata] !== newMeta[key as keyof SecretMetadata]) {
        changes[key] = { oldValue: oldMeta[key as keyof SecretMetadata], newValue: newMeta[key as keyof SecretMetadata] };
      }
    }
    return changes;
  }
}

/**
 * @class KeyManagementSystem - Manages the lifecycle of encryption keys.
 * A crucial component for "Sentinel Core" and integrations with external KMS providers.
 * Invention: "Multi-KMS Orchestrator" - abstracts away provider specifics.
 */
export class KeyManagementSystem {
  private internalKeys: Map<string, EncryptionKeyDetails>;
  private externalKmsProviders: Map<string, IKMSProvider>;
  private cryptoEngine: CryptographicEngine;
  private auditLogger: AuditLogger;
  private config: VaultConfiguration;

  constructor(cryptoEngine: CryptographicEngine, auditLogger: AuditLogger, config: VaultConfiguration) {
    this.internalKeys = new Map();
    this.externalKmsProviders = new Map();
    this.cryptoEngine = cryptoEngine;
    this.auditLogger = auditLogger;
    this.config = config;
    console.log(`[Q_Vault KMS] Initialized.`);
    this.initInternalKeys();
    this.initExternalKMS();
    // Invention: "Key Rotation Scheduler" - automates key rotation based on policy.
  }

  private async initInternalKeys(): Promise<void> {
    // Generate or load default internal keys.
    // For demonstration, we'll create a default symmetric key.
    if (!this.internalKeys.has('default_symmetric_key')) {
      const defaultKey: EncryptionKeyDetails = {
        keyId: 'default_symmetric_key',
        alias: 'Default Symmetric Encryption Key',
        type: 'SYMMETRIC',
        algorithm: 'AES-256-GCM', // Standard algorithm
        creationDate: Date.now(),
        rotationDate: undefined,
        nextRotationDate: Date.now() + (this.config.keyRotationIntervalDays[SecretType.GENERIC_VALUE] || 365) * 24 * 60 * 60 * 1000,
        isEnabled: true,
        exportable: false,
        usage: 'ENCRYPTION',
      };
      this.internalKeys.set(defaultKey.keyId, defaultKey);
      console.log(`[Q_Vault KMS] Generated default internal symmetric key: ${defaultKey.keyId}.`);
    }
    // Also consider default PQC keys handled by PostQuantumEncryptionModule directly or integrated here.
  }

  private async initExternalKMS(): Promise<void> {
    if (this.config.externalKmsConfig) {
      // Example for AWS KMS
      if (this.config.externalKmsConfig['awsKms']) {
        // Assume an AwsKmsProvider class exists
        // const awsKmsProvider = new AwsKmsProvider(this.config.externalKmsConfig['awsKms']);
        // await awsKmsProvider.initialize(this.config.externalKmsConfig['awsKms']);
        // this.externalKmsProviders.set('AWS_KMS', awsKmsProvider);
        console.log(`[Q_Vault KMS] Initialized AWS KMS provider (simulated).`);
      }
      // Example for Azure Key Vault
      if (this.config.externalKmsConfig['azureKv']) {
        // const azureKvProvider = new AzureKvProvider(this.config.externalKmsConfig['azureKv']);
        // await azureKvProvider.initialize(this.config.externalKmsConfig['azureKv']);
        // this.externalKmsProviders.set('AZURE_KEYVAULT', azureKvProvider);
        console.log(`[Q_Vault KMS] Initialized Azure Key Vault provider (simulated).`);
      }
      // Example for GCP Secret Manager (acting as a KMS for certain operations)
      if (this.config.externalKmsConfig['gcpSm']) {
        // const gcpSmProvider = new GcpSmProvider(this.config.externalKmsConfig['gcpSm']);
        // await gcpSmProvider.initialize(this.config.externalKmsConfig['gcpSm']);
        // this.externalKmsProviders.set('GCP_SECRET_MANAGER', gcpSmProvider);
        console.log(`[Q_Vault KMS] Initialized GCP Secret Manager provider (simulated).`);
      }
    }
  }

  /**
   * Retrieves details for a specific encryption key.
   * @param keyId The ID of the key.
   * @returns Key details or null if not found.
   */
  public async getKeyDetails(keyId: string): Promise<EncryptionKeyDetails | null> {
    if (this.internalKeys.has(keyId)) {
      return this.internalKeys.get(keyId)!;
    }
    // Check external KMS providers
    for (const provider of this.externalKmsProviders.values()) {
      try {
        const details = await provider.getKeyDetails(keyId);
        if (details) return details;
      } catch (e) {
        console.warn(`[Q_Vault KMS] Could not retrieve key ${keyId} from ${provider.providerName}: ${e.message}`);
      }
    }
    console.warn(`[Q_Vault KMS] Key ${keyId} not found in any managed KMS.`);
    return null;
  }

  /**
   * Rotates an encryption key.
   * Invention: "Zero-Downtime Key Rotator" - manages key transition without service interruption.
   * @param keyId The ID of the key to rotate.
   * @param actor The user performing the action.
   * @returns The new key details after rotation.
   */
  public async rotateKey(keyId: string, actor: UserId): Promise<EncryptionKeyDetails | null> {
    let keyDetails = this.internalKeys.get(keyId);
    if (keyDetails) {
      console.log(`[Q_Vault KMS] Rotating internal key: ${keyId}.`);
      // Simulate rotation: generate new key material, update details.
      keyDetails.rotationDate = Date.now();
      keyDetails.nextRotationDate = Date.now() + (this.config.keyRotationIntervalDays[SecretType.GENERIC_VALUE] || 365) * 24 * 60 * 60 * 1000;
      keyDetails.algorithm = `${keyDetails.algorithm}_rotated_${keyDetails.rotationDate}`; // Simulate new algorithm/version
      // In a real system, new key material would be generated here.
      this.internalKeys.set(keyId, keyDetails);

      await this.auditLogger.log({
        id: this.cryptoEngine.generateSecureRandom(32),
        timestamp: Date.now(),
        eventType: AuditEventType.SECRET_ROTATE, // Re-using for key rotation
        actor: actor,
        target: keyId,
        details: { newAlgorithm: keyDetails.algorithm },
        sourceIp: 'N/A',
        signedHash: await this.cryptoEngine.hash(keyId + actor + JSON.stringify(keyDetails) + Date.now()),
      });
      console.log(`[Q_Vault KMS] Internal key ${keyId} rotated successfully.`);
      return keyDetails;
    }

    // Try external KMS providers
    for (const provider of this.externalKmsProviders.values()) {
      try {
        const newKeyDetails = await provider.rotateKey(keyId);
        if (newKeyDetails) {
          await this.auditLogger.log({
            id: this.cryptoEngine.generateSecureRandom(32),
            timestamp: Date.now(),
            eventType: AuditEventType.SECRET_ROTATE,
            actor: actor,
            target: keyId,
            details: { newKeyId: newKeyDetails.keyId, provider: provider.providerName },
            sourceIp: 'N/A',
            signedHash: await this.cryptoEngine.hash(keyId + actor + JSON.stringify(newKeyDetails) + Date.now()),
          });
          console.log(`[Q_Vault KMS] External key ${keyId} rotated via ${provider.providerName}.`);
          return newKeyDetails;
        }
      } catch (e) {
        console.error(`[Q_Vault KMS] Error rotating key ${keyId} with ${provider.providerName}: ${e.message}`);
      }
    }

    console.error(`[Q_Vault KMS] Failed to rotate key ${keyId}: Key not found or rotation failed in all providers.`);
    return null;
  }

  /**
   * Retrieves the provider responsible for a given key.
   * Invention: "Key Ownership Resolver" - identifies the authoritative KMS for any key.
   * @param keyId The ID of the key.
   * @returns The IKMSProvider instance or null if internal.
   */
  public getProviderForKey(keyId: string): IKMSProvider | null {
    // For internal keys, we return null, indicating it's managed by this KMS directly.
    if (this.internalKeys.has(keyId)) {
      return null;
    }
    // For external keys, we find the provider
    for (const provider of this.externalKmsProviders.values()) {
      // In a real scenario, providers would have a way to check if they manage a key.
      // For simplicity, we assume if `getKeyDetails` worked for it, it belongs to it.
      // Or, keyId formats could indicate provider.
      // We'll return the first provider that potentially manages it.
      // This is a simplification; a real system would need a mapping.
      console.warn(`[Q_Vault KMS] Cannot definitively map external key ${keyId} to a provider without explicit registration.`);
    }
    return null; // Key not explicitly managed by external providers or internal.
  }
}

/**
 * @class AccessControlManager - Enforces granular access policies.
 * The guardian of the vault, invented during "Aegis Protocol" and enhanced with
 * "Hermes Link" for contextual and AI-driven policies.
 */
export class AccessControlManager {
  private policies: Map<PolicyId, VaultPolicy>;
  private cryptoEngine: CryptographicEngine;
  private auditLogger: AuditLogger;
  private aiPolicyGenerator: NLPSecurityPolicyGenerator; // New in "Hermes Link"

  constructor(cryptoEngine: CryptographicEngine, auditLogger: AuditLogger, aiPolicyGenerator: NLPSecurityPolicyGenerator) {
    this.policies = new Map();
    this.cryptoEngine = cryptoEngine;
    this.auditLogger = auditLogger;
    this.aiPolicyGenerator = aiPolicyGenerator;
    console.log(`[Q_Vault ACM] Initialized.`);
    // Invention: "Policy Conflict Resolver" - identifies and flags overlapping or contradictory policies.
  }

  /**
   * Evaluates if a user (or service) has permission to perform an action on a secret path.
   * Invention: "Contextual Policy Engine" - considers IP, time, and other conditions.
   * @param userId The ID of the user or service account.
   * @param roles Roles associated with the user.
   * @param vaultPath The path to the secret.
   * @param capability The action to perform (e.g., 'read', 'write', 'delete').
   * @param context Additional contextual data (IP, geo, time, AI score).
   * @returns True if access is allowed, false otherwise.
   */
  public async checkPermission(
    userId: UserId,
    roles: RoleId[],
    vaultPath: VaultPath,
    capability: string,
    context: { ipAddress?: IPAddress; geoLocation?: GeoLocation; time?: Timestamp; aiTrustScore?: number; }
  ): Promise<boolean> {
    let allowed = false;
    let explicitDeny = false;

    // Iterate through all policies relevant to the user's roles
    for (const policy of this.policies.values()) {
      // Assuming a policy could be assigned to a role, or directly to a user/group.
      // For simplicity, let's assume policies are broadly applicable or tied implicitly to roles.
      // In a real system, there'd be a mapping: User -> Roles -> Policies.
      // For this example, we assume all policies are evaluated.
      // OR, policies could have a 'subject' field { type: 'role' | 'user', id: '...' }

      for (const rule of policy.rules) {
        // Path matching: wildcards, exact match
        if (!this.matchPath(rule.path, vaultPath)) {
          continue;
        }

        // Capability matching
        if (!rule.capabilities.includes('*') && !rule.capabilities.includes(capability)) {
          continue;
        }

        // Contextual conditions evaluation (new in Hermes Link)
        if (rule.conditions && !this.evaluateConditions(rule.conditions, context)) {
          continue;
        }

        if (rule.effect === PolicyEffect.DENY) {
          explicitDeny = true; // Deny always takes precedence
          console.warn(`[Q_Vault ACM] Explicit DENY rule matched for user ${userId} on ${vaultPath} for ${capability}. Policy: ${policy.id}`);
          break; // Stop evaluating rules for this policy if denied
        } else if (rule.effect === PolicyEffect.ALLOW) {
          allowed = true; // An allow rule gives permission, but deny overrides
          console.log(`[Q_Vault ACM] ALLOW rule matched for user ${userId} on ${vaultPath} for ${capability}. Policy: ${policy.id}`);
        }
      }
      if (explicitDeny) break; // If an explicit deny was found, stop processing all policies
    }

    const finalDecision = allowed && !explicitDeny;
    console.log(`[Q_Vault ACM] Final permission decision for user ${userId} on ${vaultPath} for ${capability}: ${finalDecision ? 'ALLOW' : 'DENY'}`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: finalDecision ? AuditEventType.AUTH_SUCCESS : AuditEventType.AUTH_FAILURE,
      actor: userId,
      target: vaultPath,
      details: { capability, roles, context, decision: finalDecision ? 'ALLOW' : 'DENY', explicitDeny },
      sourceIp: context.ipAddress || 'UNKNOWN',
      geoLocation: context.geoLocation,
      aiScore: context.aiTrustScore,
      signedHash: await this.cryptoEngine.hash(userId + vaultPath + capability + JSON.stringify(context) + finalDecision + Date.now()),
    });

    return finalDecision;
  }

  private matchPath(policyPath: VaultPath, requestPath: VaultPath): boolean {
    // Basic wildcard matching: `secrets/foo/*` matches `secrets/foo/bar`, `secrets/foo/bar/baz`
    // Exact matching: `secrets/foo` matches `secrets/foo`
    // Root wildcard: `*` matches everything
    if (policyPath === '*') return true;
    if (policyPath.endsWith('/*')) {
      const basePolicyPath = policyPath.slice(0, -2);
      return requestPath.startsWith(basePolicyPath);
    }
    return policyPath === requestPath;
  }

  private evaluateConditions(conditions: PolicyCondition[], context: { ipAddress?: IPAddress; geoLocation?: GeoLocation; time?: Timestamp; aiTrustScore?: number; }): boolean {
    for (const condition of conditions) {
      let contextValue: any;
      switch (condition.field) {
        case 'ip_address':
          contextValue = context.ipAddress;
          break;
        case 'geo_location':
          contextValue = context.geoLocation?.country; // Just checking country for simplicity
          break;
        case 'time_of_day':
          contextValue = new Date(context.time || Date.now()).getUTCHours(); // 0-23
          break;
        case 'ai_trust_score':
          contextValue = context.aiTrustScore;
          break;
        // Add more fields as needed, e.g., 'user_group', 'request_origin'
        default:
          console.warn(`[Q_Vault ACM] Unknown policy condition field: ${condition.field}.`);
          continue; // Treat unknown conditions as not met, or skip
      }

      if (!contextValue) return false; // Condition not met if context data is missing

      switch (condition.operator) {
        case 'equals':
          if (contextValue !== condition.value) return false;
          break;
        case 'not_equals':
          if (contextValue === condition.value) return false;
          break;
        case 'in':
          if (!Array.isArray(condition.value) || !condition.value.includes(contextValue)) return false;
          break;
        case 'not_in':
          if (Array.isArray(condition.value) && condition.value.includes(contextValue)) return false;
          break;
        case 'greater_than':
          if (typeof contextValue !== 'number' || typeof condition.value !== 'number' || contextValue <= condition.value) return false;
          break;
        case 'less_than':
          if (typeof contextValue !== 'number' || typeof condition.value !== 'number' || contextValue >= condition.value) return false;
          break;
        case 'between':
          if (!Array.isArray(condition.value) || condition.value.length !== 2 || typeof contextValue !== 'number' ||
            typeof condition.value[0] !== 'number' || typeof condition.value[1] !== 'number' ||
            !(contextValue >= condition.value[0] && contextValue <= condition.value[1])) return false;
          break;
        default:
          console.warn(`[Q_Vault ACM] Unknown policy condition operator: ${condition.operator}.`);
          return false; // Unknown operator implies condition not met
      }
    }
    return true; // All conditions met
  }

  /**
   * Creates a new access policy.
   * @param policy The policy object to create.
   * @param actor The user creating the policy.
   * @returns The created policy.
   */
  public async createPolicy(policy: VaultPolicy, actor: UserId): Promise<VaultPolicy> {
    if (this.policies.has(policy.id)) {
      throw new Error(`Policy with ID ${policy.id} already exists.`);
    }
    policy.createdAt = Date.now();
    policy.updatedAt = Date.now();
    policy.createdBy = actor;
    this.policies.set(policy.id, policy);
    console.log(`[Q_Vault ACM] Created policy: ${policy.id}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.POLICY_CREATE,
      actor: actor,
      target: policy.id,
      details: { name: policy.name, rules: policy.rules },
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(JSON.stringify(policy) + actor + Date.now()),
    });
    return policy;
  }

  /**
   * Updates an existing access policy.
   * @param policyId The ID of the policy to update.
   * @param updates Partial updates for the policy.
   * @param actor The user updating the policy.
   * @returns The updated policy or null if not found.
   */
  public async updatePolicy(policyId: PolicyId, updates: Partial<VaultPolicy>, actor: UserId): Promise<VaultPolicy | null> {
    const existingPolicy = this.policies.get(policyId);
    if (!existingPolicy) {
      console.warn(`[Q_Vault ACM] Attempted to update non-existent policy: ${policyId}.`);
      return null;
    }
    const oldPolicy = { ...existingPolicy };
    const updatedPolicy = { ...existingPolicy, ...updates, updatedAt: Date.now() };
    this.policies.set(policyId, updatedPolicy);
    console.log(`[Q_Vault ACM] Updated policy: ${policyId}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.POLICY_UPDATE,
      actor: actor,
      target: policyId,
      details: { old: oldPolicy, new: updatedPolicy },
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(JSON.stringify(updatedPolicy) + actor + Date.now()),
    });
    return updatedPolicy;
  }

  /**
   * Deletes an access policy.
   * @param policyId The ID of the policy to delete.
   * @param actor The user deleting the policy.
   * @returns True if deleted, false if not found.
   */
  public async deletePolicy(policyId: PolicyId, actor: UserId): Promise<boolean> {
    if (!this.policies.has(policyId)) {
      console.warn(`[Q_Vault ACM] Attempted to delete non-existent policy: ${policyId}.`);
      return false;
    }
    this.policies.delete(policyId);
    console.log(`[Q_Vault ACM] Deleted policy: ${policyId}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.POLICY_DELETE,
      actor: actor,
      target: policyId,
      details: {},
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(policyId + actor + Date.now()),
    });
    return true;
  }

  /**
   * Retrieves an access policy by ID.
   * @param policyId The ID of the policy.
   * @returns The policy or null if not found.
   */
  public async getPolicy(policyId: PolicyId): Promise<VaultPolicy | null> {
    return this.policies.get(policyId) || null;
  }

  /**
   * Lists all currently defined policies.
   * @returns An array of all VaultPolicy objects.
   */
  public async listPolicies(): Promise<VaultPolicy[]> {
    return Array.from(this.policies.values());
  }

  /**
   * Generates suggested policies based on natural language input.
   * Integrates with `NLPSecurityPolicyGenerator` (ChatGPT/Gemini).
   * Invention: "Natural Language Policy Drafter" - makes security policy creation accessible.
   * @param naturalLanguageQuery A description of the desired policy.
   * @param context Additional context for the AI.
   * @returns An array of suggested policies.
   */
  public async suggestPolicies(naturalLanguageQuery: string, context: Record<string, any>): Promise<VaultPolicy[]> {
    console.log(`[Q_Vault ACM] Requesting AI policy suggestions for: "${naturalLanguageQuery}"`);
    const suggestions = await this.aiPolicyGenerator.generatePolicySuggestion(naturalLanguageQuery, context);
    console.log(`[Q_Vault ACM] Received ${suggestions.length} AI-generated policy suggestions.`);
    return suggestions;
  }
}

/**
 * @class AuditLogger - Records all security-relevant events.
 * Crucial for compliance ("Sentinel Core") and threat detection ("Hermes Link").
 * Invention: "Immutable Ledger Writer" - ensures cryptographic chaining of audit logs.
 */
export class AuditLogger {
  private logs: AuditLogEntry[]; // In-memory buffer, should be persistent storage
  private cryptoEngine: CryptographicEngine;
  private eventBus: EventBus;
  private config: VaultConfiguration;
  private lastLogHash: Hash; // For cryptographic chaining
  private readonly AUDIT_LOG_TOPIC = 'qvault.audit.events';

  constructor(cryptoEngine: CryptographicEngine, eventBus: EventBus, config: VaultConfiguration) {
    this.logs = [];
    this.cryptoEngine = cryptoEngine;
    this.eventBus = eventBus;
    this.config = config;
    this.lastLogHash = 'INITIAL_AUDIT_HASH_QVAULT_V7'; // Invention: Genesis Audit Hash
    console.log(`[Q_Vault AuditLogger] Initialized. Retention: ${config.auditRetentionDays} days.`);
    this.pruneOldLogs(); // Start pruning on init
    setInterval(() => this.pruneOldLogs(), 24 * 60 * 60 * 1000); // Daily pruning
    // Invention: "Real-time Anomaly Detection Stream" - feeds logs to AI for immediate analysis.
    this.eventBus.subscribe(this.AUDIT_LOG_TOPIC, (event) => this.onAuditLogEvent(event));
  }

  /**
   * Logs a security event. Each log entry is cryptographically signed and chained.
   * @param entry The audit log entry to record.
   */
  public async log(entry: Omit<AuditLogEntry, 'signedHash'>): Promise<void> {
    const fullEntry: AuditLogEntry = {
      ...entry,
      signedHash: await this.cryptoEngine.hash(JSON.stringify(entry) + this.lastLogHash),
    };
    this.logs.push(fullEntry);
    this.lastLogHash = fullEntry.signedHash; // Update chain hash

    // In a real system, this would write to a WORM (Write Once Read Many) storage
    // or a blockchain ledger for tamper-proof auditing.
    console.log(`[Q_Vault AuditLogger] Logged event: ${fullEntry.eventType} by ${fullEntry.actor} on ${fullEntry.target}.`);

    // Publish to event bus for real-time monitoring and AI analysis
    await this.eventBus.publish(this.AUDIT_LOG_TOPIC, fullEntry);
  }

  /**
   * Retrieves audit logs based on filters.
   * Invention: "Dynamic Log Query Processor" - supports complex queries for investigation.
   * @param filters Optional filters (e.g., actor, eventType, target, timeRange).
   * @returns An array of matching audit log entries.
   */
  public async getLogs(filters?: {
    actor?: UserId;
    eventType?: AuditEventType;
    target?: string;
    from?: Timestamp;
    to?: Timestamp;
    limit?: number;
    offset?: number;
  }): Promise<AuditLogEntry[]> {
    let filteredLogs = this.logs; // In real-world, query persistent store

    if (filters?.actor) filteredLogs = filteredLogs.filter(log => log.actor === filters.actor);
    if (filters?.eventType) filteredLogs = filteredLogs.filter(log => log.eventType === filters.eventType);
    if (filters?.target) filteredLogs = filteredLogs.filter(log => log.target === filters.target);
    if (filters?.from) filteredLogs = filteredLogs.filter(log => log.timestamp >= filters.from!);
    if (filters?.to) filteredLogs = filteredLogs.filter(log => log.timestamp <= filters.to!);

    filteredLogs.sort((a, b) => b.timestamp - a.timestamp); // Newest first

    const start = filters?.offset || 0;
    const end = start + (filters?.limit || filteredLogs.length);

    console.log(`[Q_Vault AuditLogger] Retrieved ${filteredLogs.length} logs with filters.`);
    return filteredLogs.slice(start, end);
  }

  /**
   * Prunes old audit logs based on retention policy.
   * Invention: "Automated Compliance Pruner" - ensures data lifecycle management.
   */
  private pruneOldLogs(): void {
    const cutoffTimestamp = Date.now() - this.config.auditRetentionDays * 24 * 60 * 60 * 1000;
    const initialSize = this.logs.length;
    this.logs = this.logs.filter(log => log.timestamp >= cutoffTimestamp);
    if (this.logs.length < initialSize) {
      console.log(`[Q_Vault AuditLogger] Pruned ${initialSize - this.logs.length} old audit logs.`);
    }
  }

  /**
   * Handles incoming audit log events for internal processing (e.g., passing to AI).
   */
  private onAuditLogEvent(event: AuditLogEntry): void {
    console.debug(`[Q_Vault AuditLogger] Received audit event from EventBus: ${event.eventType}`);
    // Here, you could forward specific events to an AI anomaly detection system
    // or trigger other internal processes.
  }

  /**
   * Verifies the integrity of the audit log chain.
   * Invention: "Audit Chain Integrity Verifier" - ensures non-repudiation and tamper detection.
   * @returns True if the chain is intact, false otherwise.
   */
  public async verifyAuditChainIntegrity(): Promise<boolean> {
    if (this.logs.length === 0) {
      console.log(`[Q_Vault AuditLogger] No logs to verify. Chain considered intact.`);
      return true;
    }

    let previousHash = 'INITIAL_AUDIT_HASH_QVAULT_V7'; // Our genesis hash
    for (let i = 0; i < this.logs.length; i++) {
      const currentLog = this.logs[i];
      const expectedHash = await this.cryptoEngine.hash(JSON.stringify({ ...currentLog, signedHash: undefined }) + previousHash);
      if (currentLog.signedHash !== expectedHash) {
        console.error(`[Q_Vault AuditLogger] Audit chain integrity compromised at log entry ${i}. Expected hash: ${expectedHash}, Actual: ${currentLog.signedHash}`);
        return false;
      }
      previousHash = currentLog.signedHash;
    }
    console.log(`[Q_Vault AuditLogger] Audit chain integrity verified successfully.`);
    return true;
  }
}

/**
 * @class ReplicationCoordinator - Manages data consistency across distributed vault nodes.
 * The core of "Chronos Synchronization," ensuring high availability and global reach.
 */
export class ReplicationCoordinator {
  private config: VaultConfiguration;
  private eventBus: EventBus;
  private cryptoEngine: CryptographicEngine;
  private localVaultId: string;
  private pendingReplications: Map<string, ReplicationEvent>; // For eventual consistency

  private readonly REPLICATION_TOPIC = 'qvault.replication.events';

  constructor(config: VaultConfiguration, eventBus: EventBus, cryptoEngine: CryptographicEngine, localVaultId: string) {
    this.config = config;
    this.eventBus = eventBus;
    this.cryptoEngine = cryptoEngine;
    this.localVaultId = localVaultId;
    this.pendingReplications = new Map();
    console.log(`[Q_Vault ReplicationCoordinator] Initialized for vault: ${localVaultId}. Replication enabled: ${config.replicationEnabled}.`);

    if (this.config.replicationEnabled) {
      this.eventBus.subscribe(this.REPLICATION_TOPIC, (event) => this.handleReplicationEvent(event));
      setInterval(() => this.processPendingReplications(), 5000); // Process pending every 5 seconds
    }
    // Invention: "Conflict-Free Replicated Data Type (CRDT) Adaptation Layer" - manages divergent updates.
  }

  /**
   * Triggers the replication of a secret or policy change.
   * @param data The secret or policy object to replicate.
   * @param changeType 'CREATE', 'UPDATE', 'DELETE'
   */
  public async replicateSecret(secret: VaultSecret, changeType: 'CREATE' | 'UPDATE' | 'DELETE'): Promise<void> {
    if (!this.config.replicationEnabled) {
      console.warn(`[Q_Vault ReplicationCoordinator] Replication is disabled. Skipping secret ${secret.id}.`);
      return;
    }

    const event: ReplicationEvent = {
      eventId: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      sourceClusterId: this.localVaultId,
      eventType: changeType === 'CREATE' ? AuditEventType.SECRET_WRITE : (changeType === 'UPDATE' ? AuditEventType.SECRET_UPDATE : AuditEventType.SECRET_DELETE),
      payload: { secretId: secret.id, path: secret.path, type: secret.type, value: secret.value, metadata: secret.metadata },
      sequenceNumber: secret.metadata?.version || 1, // Use secret version for sequencing
      signature: await this.cryptoEngine.sign('replication_signing_key', JSON.stringify(secret) + this.localVaultId + event.timestamp), // Invention: replication signing key
    };

    this.pendingReplications.set(event.eventId, event); // Add to pending queue before publishing
    await this.eventBus.publish(this.REPLICATION_TOPIC, event);
    console.log(`[Q_Vault ReplicationCoordinator] Replicated secret ${secret.id} with change type: ${changeType}.`);
  }

  /**
   * Handles incoming replication events from other vault clusters.
   * Invention: "Intelligent Conflict Resolution Matrix" - uses last-write-wins, merge, or human intervention for conflicts.
   * @param event The replication event to process.
   */
  private async handleReplicationEvent(event: ReplicationEvent): Promise<void> {
    if (event.sourceClusterId === this.localVaultId) {
      // Ignore events originating from this cluster, already processed locally.
      return;
    }

    console.log(`[Q_Vault ReplicationCoordinator] Received replication event from ${event.sourceClusterId}: ${event.eventType} for ${event.payload.secretId}`);

    // Verify event signature for authenticity
    const isAuthentic = await this.cryptoEngine.verify('replication_signing_key', JSON.stringify(event.payload) + event.sourceClusterId + event.timestamp, event.signature);
    if (!isAuthentic) {
      console.error(`[Q_Vault ReplicationCoordinator] WARNING: Received unauthentic replication event ${event.eventId} from ${event.sourceClusterId}. Discarding.`);
      return;
    }

    // Process based on event type
    switch (event.eventType) {
      case AuditEventType.SECRET_WRITE:
      case AuditEventType.SECRET_UPDATE:
        // Here, we would update our local SecretStore.
        // For actual consistency, this needs to check against local version, implement CRDT logic etc.
        console.log(`[Q_Vault ReplicationCoordinator] Applying secret update for ${event.payload.secretId} from ${event.sourceClusterId}.`);
        // Simulate applying update - in reality, call SecretStore directly with specific update logic
        // E.g., if local version is older, apply; if newer, log conflict or ignore.
        // This is where CRDTs (Conflict-Free Replicated Data Types) would shine.
        break;
      case AuditEventType.SECRET_DELETE:
        console.log(`[Q_Vault ReplicationCoordinator] Applying secret delete for ${event.payload.secretId} from ${event.sourceClusterId}.`);
        // Simulate applying delete
        break;
      default:
        console.warn(`[Q_Vault ReplicationCoordinator] Unhandled replication event type: ${event.eventType}.`);
    }

    // Remove from pending if this event was also locally pending (e.g., in a multi-active setup)
    this.pendingReplications.delete(event.eventId);
  }

  /**
   * Periodically checks and processes any pending replication events.
   * Invention: "Replication Lag Monitor" - tracks the latency of secret propagation.
   */
  private async processPendingReplications(): Promise<void> {
    if (this.pendingReplications.size > 0) {
      console.log(`[Q_Vault ReplicationCoordinator] Processing ${this.pendingReplications.size} pending replication events.`);
      // In a real system, pending events would be persisted and retried.
      // For now, we just log.
      this.pendingReplications.forEach((event, eventId) => {
        // If an event has been in pending for too long, re-publish or alert.
        if (Date.now() - event.timestamp > 60 * 1000) { // 1 minute threshold
          console.warn(`[Q_Vault ReplicationCoordinator] Event ${eventId} pending for over 1 minute. Re-publishing.`);
          this.eventBus.publish(this.REPLICATION_TOPIC, event);
        }
      });
    }
  }

  /**
   * Retrieves the current replication status of all configured clusters.
   * Invention: "Global Consistency Dashboard Aggregator" - provides a unified view of replication health.
   * @returns An array of cluster statuses.
   */
  public async getReplicationStatus(): Promise<{ clusterId: string; status: ReplicationStatus; lastSyncTime?: Timestamp; backlogSize?: number; }[]> {
    if (!this.config.replicationEnabled) {
      return [{ clusterId: this.localVaultId, status: ReplicationStatus.DEGRADED, backlogSize: -1 }]; // Indicate disabled as degraded locally
    }
    return this.config.replicationClusters.map(cluster => ({
      clusterId: cluster.id,
      status: cluster.status,
      lastSyncTime: Date.now(), // Placeholder, should be tracked by actual sync mechanism
      backlogSize: Math.floor(Math.random() * 10), // Simulate backlog
    }));
  }
}

/**
 * @class BackupRestoreService - Manages vault data backups and recovery.
 * The "Phoenix Initiative" was entirely focused on perfecting this critical service.
 */
export class BackupRestoreService {
  private secretStore: SecretStore;
  private cryptoEngine: CryptographicEngine;
  private auditLogger: AuditLogger;
  private config: VaultConfiguration;
  private backupTargetStorage: string; // e.g., 's3://vault-backups/', 'gcs://vault-backups/'

  constructor(secretStore: SecretStore, cryptoEngine: CryptographicEngine, auditLogger: AuditLogger, config: VaultConfiguration, backupTargetStorage: string) {
    this.secretStore = secretStore;
    this.cryptoEngine = cryptoEngine;
    this.auditLogger = auditLogger;
    this.config = config;
    this.backupTargetStorage = backupTargetStorage;
    console.log(`[Q_Vault BackupRestoreService] Initialized. Backup target: ${backupTargetStorage}.`);
    // Invention: "Incremental Backup Optimizer" - only backs up changed data chunks.
    // Invention: "Disaster Recovery Orchestrator" - automates recovery workflows.
  }

  /**
   * Initiates a full backup of the vault's secrets and configurations.
   * This is a "snapshot in time" operation.
   * @param actor The user initiating the backup.
   * @returns The backup manifest ID.
   */
  public async createFullBackup(actor: UserId): Promise<string> {
    console.log(`[Q_Vault BackupRestoreService] Initiating full vault backup by ${actor}...`);
    const backupId = `backup_${Date.now()}_${this.cryptoEngine.generateSecureRandom(8)}`;
    const allSecrets = await this.secretStore.listSecrets(); // Get all secret IDs
    const allPolicies = await (this.secretStore as any).policies ? (this.secretStore as any).listPolicies() : []; // Access ACM's policies if available
    const vaultConfig = { ...this.config }; // Current config

    const dataToBackup = {
      secrets: [], // Placeholder for actual secrets
      policies: allPolicies,
      config: vaultConfig,
      auditLogs: await this.auditLogger.getLogs({ limit: this.config.auditRetentionDays * 10000 }), // Backup recent audit logs
    };

    // In a real system, secrets would be streamed from `secretStore.getSecret(id)`
    // and encrypted individually or in chunks.
    for (const secretId of allSecrets) {
      const secret = await this.secretStore.getSecret(secretId);
      if (secret) {
        // Data here is already encrypted (VaultSecret.value is Ciphertext).
        // For backup, we might re-encrypt with a dedicated backup key.
        dataToBackup.secrets.push(secret);
      }
    }

    const encryptedDataPayload = await this.cryptoEngine.encrypt(JSON.stringify(dataToBackup), 'backup_key_id', this.config.postQuantumCryptoEnabled); // Invention: dedicated backup key.
    const dataHash = await this.cryptoEngine.hash(encryptedDataPayload);

    // Simulate writing to object storage (S3, GCS, etc.)
    const backupFilePath = `${this.backupTargetStorage}/${backupId}.enc`;
    console.log(`[Q_Vault BackupRestoreService] Uploading encrypted backup to ${backupFilePath}`);
    // await this.storageProvider.upload(backupFilePath, encryptedDataPayload); // External storage provider

    const manifest: BackupManifest = {
      backupId: backupId,
      timestamp: Date.now(),
      vaultVersion: '7.1.2',
      encryptedKeyManifestPath: `${this.backupTargetStorage}/${backupId}_keys.enc`, // Path to backup key metadata
      dataChunksMetadata: [{ chunkId: 'full_vault_data', path: backupFilePath, hash: dataHash }],
      integrityHash: await this.cryptoEngine.hash(JSON.stringify(backupId) + dataHash + Date.now()),
    };

    const encryptedManifest = await this.cryptoEngine.encrypt(JSON.stringify(manifest), 'manifest_encryption_key_id'); // Invention: manifest key
    const manifestPath = `${this.backupTargetStorage}/${backupId}_manifest.json.enc`;
    // await this.storageProvider.upload(manifestPath, encryptedManifest);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.BACKUP_EVENT,
      actor: actor,
      target: backupId,
      details: { type: 'full', manifestPath },
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(JSON.stringify(manifest) + actor + Date.now()),
    });

    console.log(`[Q_Vault BackupRestoreService] Full backup ${backupId} completed.`);
    return backupId;
  }

  /**
   * Restores the vault from a specified backup.
   * This is a highly sensitive and destructive operation.
   * @param backupId The ID of the backup to restore from.
   * @param actor The user initiating the restore.
   * @returns True if restore was successful.
   */
  public async restoreFromBackup(backupId: string, actor: UserId): Promise<boolean> {
    console.warn(`[Q_Vault BackupRestoreService] Initiating vault restore from backup ${backupId} by ${actor}. THIS WILL OVERWRITE CURRENT DATA.`);
    // Require explicit confirmation for this operation in a real UI/API.

    // Simulate downloading manifest
    const manifestPath = `${this.backupTargetStorage}/${backupId}_manifest.json.enc`;
    // const encryptedManifestData = await this.storageProvider.download(manifestPath);
    const encryptedManifestData = 'SIMULATED_ENCRYPTED_MANIFEST'; // Placeholder

    const decryptedManifestJson = await this.cryptoEngine.decrypt(encryptedManifestData, 'manifest_encryption_key_id');
    const manifest: BackupManifest = JSON.parse(decryptedManifestJson);

    if (manifest.backupId !== backupId) {
      throw new Error(`Manifest ID mismatch. Expected ${backupId}, got ${manifest.backupId}. Potential tampering.`);
    }

    // Verify manifest integrity
    const calculatedIntegrityHash = await this.cryptoEngine.hash(JSON.stringify(manifest.backupId) + manifest.dataChunksMetadata[0].hash + manifest.timestamp);
    if (calculatedIntegrityHash !== manifest.integrityHash) {
      throw new Error("Backup manifest integrity check failed. Potential data corruption or tampering.");
    }

    // Simulate downloading encrypted data
    const encryptedBackupDataPath = manifest.dataChunksMetadata[0].path;
    // const encryptedBackupData = await this.storageProvider.download(encryptedBackupDataPath);
    const encryptedBackupData = 'SIMULATED_ENCRYPTED_BACKUP_DATA'; // Placeholder

    // Verify data chunk hash
    const downloadedDataHash = await this.cryptoEngine.hash(encryptedBackupData);
    if (downloadedDataHash !== manifest.dataChunksMetadata[0].hash) {
      throw new Error("Backup data chunk integrity check failed. Data corruption detected.");
    }

    const decryptedDataJson = await this.cryptoEngine.decrypt(encryptedBackupData, 'backup_key_id', this.config.postQuantumCryptoEnabled);
    const restoredData = JSON.parse(decryptedDataJson);

    // Overwrite existing secrets and policies (clear current state first, for a full restore)
    (this.secretStore as any).secrets.clear(); // Clear in-memory cache, needs to clear persistent store too
    (this.secretStore as any).policies.clear(); // Clear policies, assuming ACM directly manages them
    // In a real system, you'd have explicit methods to clear the underlying persistent storage.

    for (const secretData of restoredData.secrets) {
      await this.secretStore.putSecret(secretData, actor); // Re-add restored secrets
    }
    for (const policyData of restoredData.policies) {
      // Assuming policies can be put directly into ACM
      // await (this.secretStore as any).accessControlManager.createPolicy(policyData, actor);
    }
    // Restore configuration (requires a method in VaultService for this)
    // await this.vaultService.updateConfiguration(restoredData.config, actor);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.RECOVERY_EVENT,
      actor: actor,
      target: backupId,
      details: { status: 'success' },
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(backupId + actor + 'success' + Date.now()),
    });

    console.log(`[Q_Vault BackupRestoreService] Vault successfully restored from backup ${backupId}.`);
    return true;
  }

  /**
   * Lists available backups in the target storage.
   * Invention: "Backup Catalog Indexer" - maintains an index of all backups for fast lookup.
   * @returns A list of BackupManifest objects.
   */
  public async listBackups(): Promise<BackupManifest[]> {
    console.log(`[Q_Vault BackupRestoreService] Listing backups from ${this.backupTargetStorage}...`);
    // Simulate listing files and parsing manifests
    const simulatedBackups: BackupManifest[] = [
      {
        backupId: 'backup_1700000000_abcde',
        timestamp: 1700000000000,
        vaultVersion: '7.0.0',
        encryptedKeyManifestPath: '',
        dataChunksMetadata: [{ chunkId: 'full_vault_data', path: '', hash: 'hash1' }],
        integrityHash: 'integrityHash1'
      },
      {
        backupId: 'backup_1701000000_fghij',
        timestamp: 1701000000000,
        vaultVersion: '7.1.0',
        encryptedKeyManifestPath: '',
                dataChunksMetadata: [{ chunkId: 'full_vault_data', path: '', hash: 'hash2' }],
        integrityHash: 'integrityHash2'
      },
    ];
    console.log(`[Q_Vault BackupRestoreService] Found ${simulatedBackups.length} simulated backups.`);
    return simulatedBackups;
  }
}

/**
 * AI/ML Integration Services - The "Oracle AI" brain of Q_Vault.
 * These services utilize advanced AI models for proactive security and intelligent operations.
 */

/**
 * @class GeminiAIThreatPrediction - Integrates with Google Gemini for advanced threat prediction.
 * New in "Oracle AI", providing real-time intelligence.
 */
export class GeminiAIThreatPrediction implements IAIModelService {
  public modelName: string = 'Google Gemini Pro (Threat Prediction)';
  private apiKey: string;
  private endpoint: string;

  constructor(apiKey: string, endpoint: string = 'https://generativelanguage.googleapis.com/v1beta') {
    this.apiKey = apiKey;
    this.endpoint = endpoint;
    console.log(`[Q_Vault GeminiAI] Initialized with endpoint: ${endpoint}`);
    // Invention: "Predictive Analytics Stream Processor" - feeds vault telemetry to Gemini for scoring.
  }

  public async initialize(config: Record<string, any>): Promise<void> {
    this.apiKey = config.apiKey || this.apiKey;
    this.endpoint = config.endpoint || this.endpoint;
    console.log(`[Q_Vault GeminiAI] Re-initialized.`);
  }

  /**
   * Analyzes an event or data point for anomalies and assigns a threat score.
   * @param data The data point to analyze (e.g., login attempt, secret access pattern).
   * @returns An object containing the anomaly score, verdict, and details.
   */
  public async analyzeAnomaly(data: Record<string, any>): Promise<{ score: number; verdict: string; details: string }> {
    console.log(`[Q_Vault GeminiAI] Sending data for anomaly analysis to Gemini: ${JSON.stringify(data)}`);
    // Simulate API call to Gemini
    // In a real scenario, this would be a structured prompt to Gemini with detailed input.
    const response = await fetch(`${this.endpoint}/models/gemini-pro:generateContent?key=${this.apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `Analyze the following vault activity for potential anomalies or threats.
                   Context: ${JSON.stringify(data)}.
                   Provide a numerical anomaly score (0.0 to 1.0), a concise verdict (e.g., 'Normal', 'Suspicious', 'Critical'), and detailed reasoning.`
          }]
        }]
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[Q_Vault GeminiAI] Gemini API error: ${response.status} - ${errorText}`);
      throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
    }

    const result = await response.json();
    const geminiText = result.candidates?.[0]?.content?.parts?.[0]?.text || '';

    // Parse Gemini's response (this requires strong prompt engineering)
    let score = 0.1;
    let verdict = 'Normal';
    let details = 'No immediate threat detected by Gemini.';

    try {
      const scoreMatch = geminiText.match(/Anomaly Score: (\d+\.\d+)/);
      if (scoreMatch && scoreMatch[1]) score = parseFloat(scoreMatch[1]);

      const verdictMatch = geminiText.match(/Verdict: (\w+)/);
      if (verdictMatch && verdictMatch[1]) verdict = verdictMatch[1];

      const detailsMatch = geminiText.match(/Reasoning: (.*)/s);
      if (detailsMatch && detailsMatch[1]) details = detailsMatch[1];

    } catch (parseError) {
      console.warn(`[Q_Vault GeminiAI] Failed to parse Gemini response, using defaults. Raw response: ${geminiText}`);
      score = 0.5 + Math.random() * 0.5; // Random for simulation
      verdict = score > 0.7 ? 'Suspicious' : 'Normal';
      details = `Simulated Gemini analysis: ${geminiText.substring(0, 100)}...`;
    }

    console.log(`[Q_Vault GeminiAI] Anomaly analysis result: Score=${score}, Verdict='${verdict}'`);
    return { score, verdict, details: details || geminiText };
  }

  public async generatePolicySuggestion(naturalLanguageQuery: string, context: Record<string, any>): Promise<VaultPolicy[]> {
    console.warn(`[Q_Vault GeminiAI] Policy generation not primary function of Gemini Threat Prediction. Using for context.`);
    // Simulate policy suggestions, likely less direct than ChatGPT
    return [{ id: 'gemini-suggested-policy-1', name: 'Gemini Anomaly Response Policy', description: 'Policy suggested by Gemini due to observed threat pattern.', createdAt: Date.now(), updatedAt: Date.now(), createdBy: 'GeminiAI', rules: [] }];
  }

  public async answerSecurityQuery(naturalLanguageQuery: string, context: Record<string, any>): Promise<string> {
    console.warn(`[Q_Vault GeminiAI] Answering security queries not primary function of Gemini Threat Prediction.`);
    return `Gemini's threat prediction capabilities indicate: "${this.predictThreatVector(context).then(r => r.description)}"`;
  }

  public async summarizeAuditLogs(logs: AuditLogEntry[]): Promise<string> {
    console.log(`[Q_Vault GeminiAI] Summarizing ${logs.length} audit logs using Gemini for high-level insights.`);
    const auditText = logs.map(log => `${new Date(log.timestamp).toISOString()} - ${log.actor} ${log.eventType} ${log.target}`).join('\n');
    // Simulate calling Gemini to summarize.
    const summaryResponse = await fetch(`${this.endpoint}/models/gemini-pro:generateContent?key=${this.apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `Summarize the following audit log entries, focusing on key events, potential security incidents, and trends.
                   Logs: ${auditText}.
                   Provide a concise executive summary.`
          }]
        }]
      })
    });

    if (!summaryResponse.ok) {
      return `[Q_Vault GeminiAI] Error summarizing logs: ${summaryResponse.statusText}`;
    }
    const result = await summaryResponse.json();
    return result.candidates?.[0]?.content?.parts?.[0]?.text || 'No summary available from Gemini.';
  }

  /**
   * Predicts potential future threat vectors based on current vault state and external intel.
   * Invention: "Anticipatory Threat Landscape Mapper" - leverages Gemini's vast knowledge base.
   * @param currentContext Current operational data (e.g., config, recent alerts).
   * @returns Predicted threat level, description, and recommended actions.
   */
  public async predictThreatVector(currentContext: Record<string, any>): Promise<{ threatLevel: number; description: string; recommendedActions: string[] }> {
    console.log(`[Q_Vault GeminiAI] Requesting threat vector prediction from Gemini.`);
    // Simulate Gemini call for prediction
    const predictionText = `Analyze the following context and predict potential security threats to the vault system.
                            Context: ${JSON.stringify(currentContext)}.
                            Provide a threat level (0-10), a description of the threat, and specific recommended actions.`;

    const response = await fetch(`${this.endpoint}/models/gemini-pro:generateContent?key=${this.apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: predictionText }] }]
      })
    });

    const result = await response.json();
    const geminiOutput = result.candidates?.[0]?.content?.parts?.[0]?.text || 'No prediction available.';

    // Example parsing:
    let threatLevel = 0;
    let description = 'No immediate high-level threat prediction available.';
    let recommendedActions: string[] = [];

    try {
      const levelMatch = geminiOutput.match(/Threat Level: (\d+)/);
      if (levelMatch) threatLevel = parseInt(levelMatch[1]);

      const descMatch = geminiOutput.match(/Description: (.*?)(\nRecommended Actions:|$)/s);
      if (descMatch) description = descMatch[1].trim();

      const actionsMatch = geminiOutput.match(/Recommended Actions:\s*(- .*(\n|$))+/s);
      if (actionsMatch) {
        recommendedActions = actionsMatch[0].split('\n').filter(line => line.startsWith('-')).map(line => line.substring(2).trim());
      }
    } catch (parseErr) {
      console.warn(`[Q_Vault GeminiAI] Failed to parse Gemini prediction, using defaults. Raw: ${geminiOutput}`);
    }

    console.log(`[Q_Vault GeminiAI] Threat prediction: Level ${threatLevel}.`);
    return { threatLevel, description, recommendedActions };
  }
}

/**
 * @class ChatGPTConversationalAssistant - Integrates with OpenAI ChatGPT for natural language querying and policy generation.
 * New in "Oracle AI", making the vault user-friendly for complex queries.
 */
export class ChatGPTConversationalAssistant implements IAIModelService {
  public modelName: string = 'OpenAI ChatGPT (Conversational Assistant)';
  private apiKey: string;
  private endpoint: string;

  constructor(apiKey: string, endpoint: string = 'https://api.openai.com/v1') {
    this.apiKey = apiKey;
    this.endpoint = endpoint;
    console.log(`[Q_Vault ChatGPT] Initialized with endpoint: ${endpoint}`);
    // Invention: "Context-Aware Dialogue Manager" - maintains conversation state for multi-turn queries.
  }

  public async initialize(config: Record<string, any>): Promise<void> {
    this.apiKey = config.apiKey || this.apiKey;
    this.endpoint = config.endpoint || this.endpoint;
    console.log(`[Q_Vault ChatGPT] Re-initialized.`);
  }

  public async analyzeAnomaly(data: Record<string, any>): Promise<{ score: number; verdict: string; details: string }> {
    console.warn(`[Q_Vault ChatGPT] Anomaly analysis not primary function of ChatGPT. Delegating to Gemini if available.`);
    return { score: Math.random() * 0.5, verdict: 'Info', details: 'ChatGPT not optimized for numerical anomaly detection.' };
  }

  /**
   * Generates suggested policies based on natural language input.
   * Invention: "Declarative Policy Synthesizer" - translates human language to structured policy.
   * @param naturalLanguageQuery A description of the desired policy.
   * @param context Additional context for the AI.
   * @returns An array of suggested policies.
   */
  public async generatePolicySuggestion(naturalLanguageQuery: string, context: Record<string, any>): Promise<VaultPolicy[]> {
    console.log(`[Q_Vault ChatGPT] Requesting policy suggestions from ChatGPT for: "${naturalLanguageQuery}"`);
    const prompt = `You are an expert security architect designing access control policies for a high-security vault.
                    Translate the following natural language request into a valid JSON array of VaultPolicy objects,
                    adhering to the VaultPolicy, PolicyRule, and PolicyCondition TypeScript interfaces.
                    Focus on granular permissions (read, write, delete, rotate) and specific paths.
                    If conditions like IP address, geo-location, or time of day are mentioned, include them.
                    Ensure the policies are logical and secure. Provide only the JSON output, no additional text.

                    Natural Language Request: "${naturalLanguageQuery}"
                    Current System Context: ${JSON.stringify(context)}

                    Example output structure:
                    [
                      {
                        "id": "policy_id_1",
                        "name": "Policy Name",
                        "description": "Policy Description",
                        "rules": [
                          {
                            "path": "secret/path/*",
                            "capabilities": ["read"],
                            "effect": "ALLOW",
                            "conditions": [
                              { "field": "ip_address", "operator": "in", "value": ["192.168.1.0/24"] }
                            ]
                          }
                        ],
                        "createdAt": 123456789,
                        "updatedAt": 123456789,
                        "createdBy": "ChatGPT"
                      }
                    ]`;

    const response = await fetch(`${this.endpoint}/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-4o', // Or gpt-3.5-turbo, etc.
        messages: [{ role: 'system', content: prompt }],
        temperature: 0.7,
        max_tokens: 1500,
        response_format: { type: "json_object" }, // Important for structured output
      })
    });

    if (!response.ok) {
      const errorDetails = await response.text();
      console.error(`[Q_Vault ChatGPT] ChatGPT API error: ${response.status} - ${errorDetails}`);
      throw new Error(`ChatGPT API error: ${response.status} - ${errorDetails}`);
    }

    const result = await response.json();
    const jsonOutput = result.choices?.[0]?.message?.content;

    try {
      const policies = JSON.parse(jsonOutput) as VaultPolicy[];
      console.log(`[Q_Vault ChatGPT] Generated ${policies.length} policies from natural language.`);
      return policies.map(p => ({
        ...p,
        id: p.id || `gpt_policy_${this.cryptoEngine.generateSecureRandom(8)}`, // Ensure ID
        createdAt: p.createdAt || Date.now(),
        updatedAt: p.updatedAt || Date.now(),
        createdBy: p.createdBy || 'ChatGPT',
      }));
    } catch (parseError) {
      console.error(`[Q_Vault ChatGPT] Failed to parse ChatGPT policy output: ${parseError}. Raw: ${jsonOutput}`);
      throw new Error("Failed to parse AI policy suggestions.");
    }
  }

  /**
   * Answers natural language queries about the vault's state, configurations, or operations.
   * Invention: "Cognitive Vault Oracle" - allows non-technical users to interact with complex systems.
   * @param naturalLanguageQuery The user's query.
   * @param context Additional context (e.g., current user, recent actions, available audit logs).
   * @returns A natural language answer.
   */
  public async answerSecurityQuery(naturalLanguageQuery: string, context: Record<string, any>): Promise<string> {
    console.log(`[Q_Vault ChatGPT] Answering query from ChatGPT: "${naturalLanguageQuery}"`);
    const prompt = `You are a helpful and knowledgeable security assistant for the QuantumSecure Vault (Q_Vault).
                    Answer the following question about the vault system based on the provided context.
                    Be concise, accurate, and professional. If you don't know the answer, state that you cannot provide it based on the available information.

                    Question: "${naturalLanguageQuery}"
                    Current Vault Context (partial, for security): ${JSON.stringify(context)}
                    (Note: Do not reveal actual secret values or sensitive configuration parameters in your answer unless specifically instructed and authorized.)
                    `;

    const response = await fetch(`${this.endpoint}/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [{ role: 'system', content: prompt }],
        temperature: 0.5,
        max_tokens: 500
      })
    });

    if (!response.ok) {
      const errorDetails = await response.text();
      console.error(`[Q_Vault ChatGPT] ChatGPT API error: ${response.status} - ${errorDetails}`);
      return `Error communicating with ChatGPT: ${response.statusText}`;
    }

    const result = await response.json();
    const answer = result.choices?.[0]?.message?.content || 'I apologize, I could not process that request.';
    console.log(`[Q_Vault ChatGPT] Answered query: ${answer.substring(0, 100)}...`);
    return answer;
  }

  public async summarizeAuditLogs(logs: AuditLogEntry[]): Promise<string> {
    console.log(`[Q_Vault ChatGPT] Summarizing ${logs.length} audit logs using ChatGPT for detailed narrative insights.`);
    const auditText = logs.map(log => JSON.stringify(log)).join('\n');
    const prompt = `You are a security analyst tasked with summarizing a large volume of Q_Vault audit logs.
                    Review the following JSON-formatted audit log entries and provide a detailed summary.
                    Highlight critical events, suspicious patterns, user activity trends, and any potential security incidents.
                    Format the summary as a professional report.

                    Audit Logs (JSON format, one per line):
                    ${auditText}`;

    const response = await fetch(`${this.endpoint}/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [{ role: 'system', content: prompt }],
        temperature: 0.6,
        max_tokens: 2000
      })
    });

    if (!response.ok) {
      return `[Q_Vault ChatGPT] Error summarizing logs: ${response.statusText}`;
    }
    const result = await response.json();
    return result.choices?.[0]?.message?.content || 'No detailed summary available from ChatGPT.';
  }

  public async predictThreatVector(currentContext: Record<string, any>): Promise<{ threatLevel: number; description: string; recommendedActions: string[] }> {
    console.warn(`[Q_Vault ChatGPT] Threat prediction not primary function of ChatGPT. Delegating to Gemini if available.`);
    return { threatLevel: 0, description: 'ChatGPT can describe potential threats but is not optimized for real-time prediction.', recommendedActions: [] };
  }
}

/**
 * @class NLPSecurityPolicyGenerator - Specialized wrapper for policy generation using LLMs.
 * An abstraction layer for the `IAIModelService` specific to policy creation.
 */
export class NLPSecurityPolicyGenerator implements IAIModelService {
  public modelName: string = 'NLP Security Policy Generator (Hybrid)';
  private primaryLLM: ChatGPTConversationalAssistant; // Prefers ChatGPT for policy gen
  private secondaryLLM?: GeminiAIThreatPrediction; // Optionally use Gemini for validation/context

  constructor(primaryLLM: ChatGPTConversationalAssistant, secondaryLLM?: GeminiAIThreatPrediction) {
    this.primaryLLM = primaryLLM;
    this.secondaryLLM = secondaryLLM;
    console.log(`[Q_Vault NLPSecurityPolicyGenerator] Initialized with primary: ${primaryLLM.modelName}.`);
    // Invention: "Policy Validation Co-Processor" - uses a secondary AI model to cross-reference and validate generated policies.
  }

  public async initialize(config: Record<string, any>): Promise<void> {
    await this.primaryLLM.initialize(config);
    if (this.secondaryLLM) {
      await this.secondaryLLM.initialize(config);
    }
  }

  public async analyzeAnomaly(data: Record<string, any>): Promise<{ score: number; verdict: string; details: string }> {
    if (this.secondaryLLM) {
      return this.secondaryLLM.analyzeAnomaly(data);
    }
    return this.primaryLLM.analyzeAnomaly(data);
  }

  public async generatePolicySuggestion(naturalLanguageQuery: string, context: Record<string, any>): Promise<VaultPolicy[]> {
    const policies = await this.primaryLLM.generatePolicySuggestion(naturalLanguageQuery, context);

    if (this.secondaryLLM && policies.length > 0) {
      console.log(`[Q_Vault NLPSecurityPolicyGenerator] Validating generated policies with secondary AI...`);
      // Simulate sending policy to secondary AI for "validation" or risk assessment
      const validationContext = {
        generatedPolicies: policies.map(p => ({ name: p.name, rules: p.rules })),
        originalQuery: naturalLanguageQuery,
        systemContext: context
      };
      // Imagine secondary LLM analyzing for loopholes, overly broad permissions, etc.
      // This is an advanced feature that would require careful prompt engineering for the secondary LLM.
      const validationResponse = await this.secondaryLLM.answerSecurityQuery(
        `Review these suggested policies for security best practices and potential vulnerabilities.
         Are there any red flags or recommendations for refinement?`,
        validationContext
      );
      console.log(`[Q_Vault NLPSecurityPolicyGenerator] Secondary AI validation feedback: ${validationResponse.substring(0, 100)}...`);
      // A more advanced integration would parse this feedback and auto-correct or flag policies.
    }
    return policies;
  }

  public async answerSecurityQuery(naturalLanguageQuery: string, context: Record<string, any>): Promise<string> {
    return this.primaryLLM.answerSecurityQuery(naturalLanguageQuery, context);
  }

  public async summarizeAuditLogs(logs: AuditLogEntry[]): Promise<string> {
    if (this.secondaryLLM) {
      return this.secondaryLLM.summarizeAuditLogs(logs); // Gemini might be better for high-level summaries
    }
    return this.primaryLLM.summarizeAuditLogs(logs);
  }

  public async predictThreatVector(currentContext: Record<string, any>): Promise<{ threatLevel: number; description: string; recommendedActions: string[] }> {
    if (this.secondaryLLM) {
      return this.secondaryLLM.predictThreatVector(currentContext);
    }
    // Fallback if no dedicated threat prediction
    return { threatLevel: 0, description: 'No dedicated threat prediction module available.', recommendedActions: [] };
  }
}

/**
 * Dynamic Secret Providers - The "Phoenix Initiative" came alive with these.
 * They enable JIT (Just-In-Time) secret generation and rotation.
 */

/**
 * @class DynamicSecretManager - Manages dynamic secrets like database credentials, SSH keys, and certificates.
 * Invention: "Ephemeral Credential Generator" - creates short-lived, single-use credentials.
 */
export class DynamicSecretManager {
  private secretStore: SecretStore;
  private cryptoEngine: CryptographicEngine;
  private auditLogger: AuditLogger;
  private dbConnectors: Map<string, IDatabaseConnector>;
  private caProviders: Map<string, ICertificateAuthority>;
  private liveLeases: Map<string, any>; // Stores active leases (DB, SSH, Cert)
  private leaseRenewalScheduler: NodeJS.Timeout; // For automated renewal/revocation

  constructor(secretStore: SecretStore, cryptoEngine: CryptographicEngine, auditLogger: AuditLogger) {
    this.secretStore = secretStore;
    this.cryptoEngine = cryptoEngine;
    this.auditLogger = auditLogger;
    this.dbConnectors = new Map();
    this.caProviders = new Map();
    this.liveLeases = new Map();

    console.log(`[Q_Vault DynamicSecretManager] Initialized.`);
    // Invention: "Lease Lifecycle Automation Engine" - manages creation, renewal, and revocation.
    this.leaseRenewalScheduler = setInterval(() => this.monitorLeases(), 60 * 1000); // Check leases every minute
  }

  public registerDatabaseConnector(connector: IDatabaseConnector): void {
    this.dbConnectors.set(connector.dbType, connector);
    console.log(`[Q_Vault DynamicSecretManager] Registered DB connector for type: ${connector.dbType}.`);
  }

  public registerCertificateAuthority(ca: ICertificateAuthority): void {
    this.caProviders.set(ca.caName, ca);
    console.log(`[Q_Vault DynamicSecretManager] Registered CA provider: ${ca.caName}.`);
  }

  /**
   * Generates dynamic database credentials with a limited lease.
   * @param dbType The type of database (e.g., 'PostgreSQL', 'MySQL').
   * @param baseConnectionString Encrypted connection string to the database's admin interface.
   * @param usernamePrefix Prefix for the generated username.
   * @param roles Roles/permissions for the new user.
   * @param ttlSeconds Time-to-live for the credentials.
   * @param actor The user requesting the dynamic secret.
   * @returns A DatabaseCredentialLease object.
   */
  public async generateDatabaseCredentials(
    dbType: string,
    baseConnectionStringId: SecretId, // Reference to encrypted base connection string
    usernamePrefix: string,
    roles: string[],
    ttlSeconds: number,
    actor: UserId
  ): Promise<DatabaseCredentialLease> {
    const connector = this.dbConnectors.get(dbType);
    if (!connector) throw new Error(`No database connector registered for type: ${dbType}.`);

    const encryptedBaseConnectionStringSecret = await this.secretStore.getSecret(baseConnectionStringId);
    if (!encryptedBaseConnectionStringSecret) throw new Error(`Base connection string secret ${baseConnectionStringId} not found.`);

    const baseConnectionString = await this.cryptoEngine.decrypt(encryptedBaseConnectionStringSecret.value);

    const { username, password } = await connector.provisionUser(
      baseConnectionString,
      usernamePrefix,
      32, // Password length
      roles,
      ttlSeconds
    );

    const leaseId = `db_lease_${this.cryptoEngine.generateSecureRandom(12)}`;
    const lease: DatabaseCredentialLease = {
      username,
      password, // Plaintext for immediate use, but highly ephemeral.
      connectionString: baseConnectionString, // Or a derived connection string for the new user
      validUntil: Date.now() + ttlSeconds * 1000,
      leaseId,
      databaseType: dbType,
      rotatedFromSecretId: baseConnectionStringId,
    };
    this.liveLeases.set(leaseId, lease);
    console.log(`[Q_Vault DynamicSecretManager] Generated dynamic DB credentials for user ${username}, lease ${leaseId}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.TOKEN_ISSUE, // Reusing for dynamic credential issue
      actor: actor,
      target: leaseId,
      details: { dbType, username, validUntil: lease.validUntil, ttl: ttlSeconds, roles },
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(JSON.stringify(lease) + actor + Date.now()),
    });
    return lease;
  }

  /**
   * Generates a dynamic SSH key pair signed by a vault-managed CA.
   * Invention: "SSH Certificate Authority" - internal CA for signing ephemeral SSH keys.
   * @param sshCaId The SecretId of the SSH CA private key.
   * @param authorizedForHosts List of hosts this key is authorized for.
   * @param ttlSeconds Time-to-live for the key.
   * @param actor The user requesting the key.
   * @returns An SSHKeyLease object.
   */
  public async generateSSHKey(
    sshCaId: SecretId, // Refers to a VaultSecret containing the SSH CA's private key
    authorizedForHosts: string[],
    ttlSeconds: number,
    actor: UserId
  ): Promise<SSHKeyLease> {
    // In a real system, generate a new ephemeral key pair.
    const newPrivateKey = `SSH_PRIV_${this.cryptoEngine.generateSecureRandom(64)}`;
    const newPublicKey = `SSH_PUB_${this.cryptoEngine.generateSecureRandom(64)}`;

    // Simulate signing with internal SSH CA.
    // This requires an internal PKI system or a dedicated SSH CA module.
    console.log(`[Q_Vault DynamicSecretManager] Signing SSH public key with CA ${sshCaId}.`);
    // Example: call a specific `SshCertificateAuthority`
    // const signedPublicKey = await this.sshCaService.signSshPublicKey(newPublicKey, authorizedForHosts, ttlSeconds);

    const leaseId = `ssh_lease_${this.cryptoEngine.generateSecureRandom(12)}`;
    const lease: SSHKeyLease = {
      publicKey: newPublicKey, // Or the signed certificate
      privateKey: newPrivateKey,
      validUntil: Date.now() + ttlSeconds * 1000,
      leaseId,
      authorizedForHosts,
      rotatedFromSecretId: sshCaId,
    };
    this.liveLeases.set(leaseId, lease);
    console.log(`[Q_Vault DynamicSecretManager] Generated dynamic SSH key, lease ${leaseId}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.TOKEN_ISSUE,
      actor: actor,
      target: leaseId,
      details: { authorizedForHosts, validUntil: lease.validUntil, ttl: ttlSeconds },
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(JSON.stringify(lease) + actor + Date.now()),
    });
    return lease;
  }

  /**
   * Generates a dynamic TLS certificate signed by an internal or external CA.
   * @param caName The name of the Certificate Authority to use (registered via `registerCertificateAuthority`).
   * @param commonName The common name for the certificate.
   * @param altNames Alternative names (SANs) for the certificate.
   * @param ttlSeconds Time-to-live for the certificate.
   * @param actor The user requesting the certificate.
   * @returns A CertificateLease object.
   */
  public async generateCertificate(
    caName: string,
    commonName: string,
    altNames: string[],
    ttlSeconds: number,
    actor: UserId
  ): Promise<CertificateLease> {
    const caProvider = this.caProviders.get(caName);
    if (!caProvider) throw new Error(`No CA provider registered for name: ${caName}.`);

    // Simulate CSR generation
    const csr = `CSR_FOR_${commonName}_${this.cryptoEngine.generateSecureRandom(10)}`;
    const certificateLease = await caProvider.issueCertificate(csr, ttlSeconds, commonName, altNames);

    const leaseId = `cert_lease_${this.cryptoEngine.generateSecureRandom(12)}`;
    const fullLease: CertificateLease = { ...certificateLease, leaseId };
    this.liveLeases.set(leaseId, fullLease);
    console.log(`[Q_Vault DynamicSecretManager] Generated dynamic certificate for ${commonName}, lease ${leaseId}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.TOKEN_ISSUE,
      actor: actor,
      target: leaseId,
      details: { commonName, altNames, validUntil: fullLease.validUntil, ttl: ttlSeconds, ca: caName },
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(JSON.stringify(fullLease) + actor + Date.now()),
    });
    return fullLease;
  }

  /**
   * Revokes a dynamic lease immediately.
   * @param leaseId The ID of the lease to revoke.
   * @param actor The user revoking the lease.
   * @returns True if revocation was successful.
   */
  public async revokeLease(leaseId: string, actor: UserId): Promise<boolean> {
    const lease = this.liveLeases.get(leaseId);
    if (!lease) {
      console.warn(`[Q_Vault DynamicSecretManager] Attempted to revoke non-existent lease: ${leaseId}.`);
      return false;
    }

    if (lease.databaseType) {
      const connector = this.dbConnectors.get(lease.databaseType);
      if (connector) await connector.revokeUser(lease.connectionString, lease.username);
    } else if (lease.certificate) {
      // Logic to revoke certificate with the issuing CA.
      // Assumes we can identify the CA from the lease or metadata.
      console.warn(`[Q_Vault DynamicSecretManager] Certificate revocation for ${leaseId} not fully implemented in simulation.`);
    }
    // Similar logic for SSH keys.

    this.liveLeases.delete(leaseId);
    console.log(`[Q_Vault DynamicSecretManager] Revoked lease: ${leaseId}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.TOKEN_REVOKE,
      actor: actor,
      target: leaseId,
      details: { leaseType: lease.databaseType ? 'database' : (lease.certificate ? 'certificate' : 'ssh_key') },
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(leaseId + actor + Date.now()),
    });
    return true;
  }

  /**
   * Monitors active leases and revokes expired ones.
   * Invention: "Automated Lease Reaper" - ensures secrets don't outlive their utility.
   */
  private async monitorLeases(): Promise<void> {
    const now = Date.now();
    for (const [leaseId, lease] of this.liveLeases.entries()) {
      if (lease.validUntil <= now) {
        console.log(`[Q_Vault DynamicSecretManager] Lease ${leaseId} expired. Initiating automatic revocation.`);
        await this.revokeLease(leaseId, 'system_auto_reaper'); // Revoked by system
      }
      // Future: implement pre-expiration renewal logic if requested.
    }
  }

  /**
   * Cleans up the lease renewal scheduler.
   */
  public shutdown(): void {
    clearInterval(this.leaseRenewalScheduler);
    console.log(`[Q_Vault DynamicSecretManager] Lease renewal scheduler stopped.`);
  }
}

/**
 * @class AuthenticationManager - Handles user and service authentication.
 * A critical component of "Aegis Protocol", with multi-factor and external IdP support.
 */
export class AuthenticationManager {
  private cryptoEngine: CryptographicEngine;
  private auditLogger: AuditLogger;
  private externalIdPs: Map<string, IIdentityProvider>;
  private activeSessions: Map<Token, SessionToken>; // In-memory active sessions
  private config: VaultConfiguration;

  constructor(cryptoEngine: CryptographicEngine, auditLogger: AuditLogger, config: VaultConfiguration) {
    this.cryptoEngine = cryptoEngine;
    this.auditLogger = auditLogger;
    this.externalIdPs = new Map();
    this.activeSessions = new Map();
    this.config = config;
    console.log(`[Q_Vault AuthenticationManager] Initialized.`);
    // Invention: "Adaptive MFA Enforcer" - dynamically requires MFA based on risk score (from AI).
  }

  public registerIdentityProvider(idp: IIdentityProvider): void {
    this.externalIdPs.set(idp.providerName, idp);
    console.log(`[Q_Vault AuthenticationManager] Registered Identity Provider: ${idp.providerName}.`);
  }

  /**
   * Authenticates a user or service and issues a session token.
   * Supports various authentication methods.
   * @param method The authentication method to use.
   * @param credentials The credentials specific to the method.
   * @param sourceIp The IP address of the client.
   * @param mfaCode Optional: Multi-Factor Authentication code.
   * @returns A session token.
   */
  public async authenticate(
    method: AuthMethod,
    credentials: Record<string, any>,
    sourceIp: IPAddress,
    mfaCode?: string
  ): Promise<SessionToken> {
    let userId: UserId | null = null;
    let roles: RoleId[] = [];
    let mfaVerified = false;

    console.log(`[Q_Vault AuthenticationManager] Attempting authentication via ${method} from ${sourceIp}.`);

    switch (method) {
      case AuthMethod.USERNAME_PASSWORD:
        // Simulate password check. In real system, this would be hashed and salted.
        if (credentials.username === 'admin' && credentials.password === 'supersecurepass') {
          userId = 'admin_user';
          roles = ['admin', 'developer'];
        } else {
          throw new Error('Invalid username or password.');
        }
        break;
      case AuthMethod.SAML:
      case AuthMethod.OIDC:
      case AuthMethod.LDAP:
        const idp = this.externalIdPs.get(method);
        if (!idp) throw new Error(`Identity Provider for ${method} not registered.`);
        const authResult = await idp.authenticate(credentials);
        userId = authResult.userId;
        roles = authResult.roles;
        break;
      case AuthMethod.JWT:
        // Validate JWT token, extract userId and roles.
        // Requires a JWT library for validation (signature, expiry, issuer).
        const decodedJwt = this.decodeAndVerifyJwt(credentials.token); // Invention: JWT Validation Engine
        userId = decodedJwt.sub;
        roles = decodedJwt.roles || [];
        break;
      case AuthMethod.AWS_IAM:
        // Authenticate using AWS IAM credentials (e.g., assumed role, access key)
        userId = `aws_iam_${credentials.accessKeyId}`;
        roles = ['aws_auditor']; // Simplified
        break;
      case AuthMethod.MFA_BIO:
        // Simulate biometric authentication. Needs integration with biometric provider.
        if (credentials.biometricScan === 'VALID_SCAN') { // Placeholder
          mfaVerified = true;
          userId = credentials.userId; // Assume userId comes with biometric request
          roles = await this.getUserRoles(userId);
        } else {
          throw new Error('Biometric authentication failed.');
        }
        break;
      default:
        throw new Error(`Unsupported authentication method: ${method}.`);
    }

    if (!userId) {
      await this.auditLogger.log({
        id: this.cryptoEngine.generateSecureRandom(32),
        timestamp: Date.now(),
        eventType: AuditEventType.AUTH_FAILURE,
        actor: 'UNKNOWN',
        target: `auth_attempt_${method}`,
        details: { method, sourceIp, reason: 'No User ID Resolved' },
        sourceIp,
        signedHash: await this.cryptoEngine.hash(`UNKNOWN ${method} ${sourceIp} ${Date.now()}`),
      });
      throw new Error('Authentication failed: User ID could not be resolved.');
    }

    // MFA Enforcement (Invention: "Multi-Factor Policy Evaluator")
    if (this.config.mfaRequiredForAdmin && roles.includes('admin') && !mfaVerified) {
      if (!mfaCode) {
        throw new Error('MFA required for admin roles. Please provide an MFA code.');
      }
      // Simulate MFA code verification
      if (mfaCode === '123456') { // Placeholder for OTP or similar check
        mfaVerified = true;
        console.log(`[Q_Vault AuthenticationManager] MFA code verified for ${userId}.`);
      } else {
        await this.auditLogger.log({
          id: this.cryptoEngine.generateSecureRandom(32),
          timestamp: Date.now(),
          eventType: AuditEventType.AUTH_FAILURE,
          actor: userId,
          target: `MFA_ATTEMPT`,
          details: { method, sourceIp, reason: 'MFA Failed' },
          sourceIp,
          signedHash: await this.cryptoEngine.hash(`${userId} MFA ${sourceIp} ${Date.now()}`),
        });
        throw new Error('Invalid MFA code.');
      }
    }

    const token = this.cryptoEngine.generateSecureRandom(64); // Secure random token
    const issuedAt = Date.now();
    const expiresAt = issuedAt + 3600 * 1000; // 1 hour validity

    const session: SessionToken = {
      token,
      userId,
      issuedAt,
      expiresAt,
      authMethod: method,
      permissions: [], // Permissions will be resolved via ACM
      sourceIp,
      mfaVerified,
    };
    this.activeSessions.set(token, session);
    console.log(`[Q_Vault AuthenticationManager] User ${userId} authenticated successfully. Session created.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.AUTH_SUCCESS,
      actor: userId,
      target: `session_${token.substring(0, 10)}`,
      details: { method, sourceIp, expiresAt, mfaVerified },
      sourceIp,
      signedHash: await this.cryptoEngine.hash(JSON.stringify(session) + Date.now()),
    });
    return session;
  }

  /**
   * Retrieves the roles associated with a user.
   * Invention: "Role Aggregator" - combines roles from multiple sources (internal, IdP).
   * @param userId The ID of the user.
   * @returns An array of RoleIds.
   */
  public async getUserRoles(userId: UserId): Promise<RoleId[]> {
    const roles: RoleId[] = [];
    // Simulate internal role mapping
    if (userId === 'admin_user') roles.push('admin', 'security_auditor');
    if (userId.startsWith('dev_')) roles.push('developer');
    if (userId.startsWith('ops_')) roles.push('operator');

    // Query external IdPs for roles
    for (const idp of this.externalIdPs.values()) {
      try {
        const idpRoles = await idp.getUserRoles(userId);
        roles.push(...idpRoles);
      } catch (e) {
        console.warn(`[Q_Vault AuthenticationManager] Could not retrieve roles for ${userId} from ${idp.providerName}: ${e.message}`);
      }
    }
    // Deduplicate roles
    const uniqueRoles = [...new Set(roles)];
    console.log(`[Q_Vault AuthenticationManager] Retrieved roles for ${userId}: ${uniqueRoles.join(', ')}`);
    return uniqueRoles;
  }

  /**
   * Validates a session token and returns the session details.
   * @param token The session token.
   * @returns The SessionToken object or null if invalid/expired.
   */
  public async validateSession(token: Token): Promise<SessionToken | null> {
    const session = this.activeSessions.get(token);
    if (!session) {
      console.warn(`[Q_Vault AuthenticationManager] Invalid session token: ${token.substring(0, 10)}...`);
      return null;
    }
    if (session.expiresAt <= Date.now()) {
      console.log(`[Q_Vault AuthenticationManager] Expired session token: ${token.substring(0, 10)}...`);
      this.activeSessions.delete(token); // Clean up expired session
      return null;
    }
    // Re-resolve permissions on each validation (or cache for a short period)
    session.permissions = await this.resolvePermissionsForSession(session);
    return session;
  }

  /**
   * Resolves the full set of permissions for a session based on user roles and policies.
   * Invention: "Real-time Permission Compiler" - dynamically generates permission sets.
   * @param session The active session.
   * @returns An array of permission strings (e.g., 'secret:read:/path', 'policy:manage:*').
   */
  private async resolvePermissionsForSession(session: SessionToken): Promise<string[]> {
    const permissions: string[] = [];
    const roles = await this.getUserRoles(session.userId);
    // This would involve iterating through ACM policies and compiling effective permissions.
    // For simplicity, we'll return a placeholder.
    if (roles.includes('admin')) {
      permissions.push('*'); // Admin has all permissions
    } else {
      permissions.push('secret:read:/users/*', 'secret:write:/users/' + session.userId + '/*', 'audit:read:self');
    }
    return permissions;
  }

  /**
   * Revokes an active session token.
   * @param token The token to revoke.
   * @param actor The user/system revoking the token.
   * @returns True if revoked, false if not found.
   */
  public async revokeSession(token: Token, actor: UserId): Promise<boolean> {
    const session = this.activeSessions.get(token);
    if (!session) {
      console.warn(`[Q_Vault AuthenticationManager] Attempted to revoke non-existent session: ${token.substring(0, 10)}...`);
      return false;
    }
    this.activeSessions.delete(token);
    console.log(`[Q_Vault AuthenticationManager] Session revoked for user ${session.userId}.`);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.TOKEN_REVOKE,
      actor: actor,
      target: `session_${token.substring(0, 10)}`,
      details: { userId: session.userId, sourceIp: session.sourceIp },
      sourceIp: session.sourceIp,
      signedHash: await this.cryptoEngine.hash(JSON.stringify(session) + actor + Date.now()),
    });
    return true;
  }

  /**
   * Simulates JWT decoding and verification.
   * Invention: "Ephemeral Token Verifier" - handles short-lived, external tokens securely.
   * @param jwt The JWT string.
   * @returns Decoded payload (simplified).
   */
  private decodeAndVerifyJwt(jwt: string): { sub: UserId; roles: RoleId[]; exp: number; } {
    // In a real application, use a library like `jsonwebtoken` to verify signature, expiry, audience, etc.
    const parts = jwt.split('.');
    if (parts.length !== 3) throw new Error("Invalid JWT format.");
    const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());
    if (payload.exp * 1000 < Date.now()) throw new Error("JWT expired.");
    console.log(`[Q_Vault AuthenticationManager] JWT verified for subject: ${payload.sub}.`);
    return payload; // Simplified, assumes payload has 'sub' and 'roles'
  }
}

/**
 * @class VaultConfigurationManager - Manages the configuration of the entire Q_Vault system.
 * Centralized control for the "Project Chimera" architecture.
 */
export class VaultConfigurationManager {
  private currentConfig: VaultConfiguration;
  private cryptoEngine: CryptographicEngine;
  private auditLogger: AuditLogger;
  private eventBus: EventBus;
  private readonly CONFIG_TOPIC = 'qvault.config.updates';

  constructor(initialConfig: VaultConfiguration, cryptoEngine: CryptographicEngine, auditLogger: AuditLogger, eventBus: EventBus) {
    this.currentConfig = initialConfig;
    this.cryptoEngine = cryptoEngine;
    this.auditLogger = auditLogger;
    this.eventBus = eventBus;
    console.log(`[Q_Vault ConfigManager] Initialized with config version: 7.1.2.`);
    // Invention: "Dynamic Configuration Hot-Reload" - applies config changes without service restart.
    this.eventBus.subscribe(this.CONFIG_TOPIC, (event) => this.handleRemoteConfigUpdate(event));
  }

  /**
   * Retrieves the current vault configuration.
   * @returns The current VaultConfiguration object.
   */
  public async getConfiguration(): Promise<VaultConfiguration> {
    // In a real system, this might fetch from a distributed config store (e.g., Consul, Etcd).
    return JSON.parse(JSON.stringify(this.currentConfig)); // Return a deep copy to prevent direct modification
  }

  /**
   * Updates a portion of the vault configuration.
   * @param updates Partial updates to apply to the configuration.
   * @param actor The user or system making the change.
   * @returns The updated configuration.
   */
  public async updateConfiguration(updates: Partial<VaultConfiguration>, actor: UserId): Promise<VaultConfiguration> {
    const oldConfig = { ...this.currentConfig };
    this.currentConfig = { ...this.currentConfig, ...updates };

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.VAULT_CONFIG_UPDATE,
      actor: actor,
      target: 'system_config',
      details: { changes: this.getChanges(oldConfig, this.currentConfig) },
      sourceIp: 'N/A',
      signedHash: await this.cryptoEngine.hash(JSON.stringify(this.currentConfig) + actor + Date.now()),
    });

    // Publish config update to the event bus for other modules/nodes to pick up.
    await this.eventBus.publish(this.CONFIG_TOPIC, { updatedConfig: this.currentConfig, actor, timestamp: Date.now() });

    console.log(`[Q_Vault ConfigManager] Configuration updated by ${actor}.`);
    return JSON.parse(JSON.stringify(this.currentConfig));
  }

  /**
   * Handles remote configuration updates received via the event bus.
   * Invention: "Configuration Consensus Protocol" - ensures all nodes converge on same config.
   * @param event The configuration update event.
   */
  private async handleRemoteConfigUpdate(event: { updatedConfig: VaultConfiguration; actor: UserId; timestamp: Timestamp; }): Promise<void> {
    console.log(`[Q_Vault ConfigManager] Received remote config update from ${event.actor}.`);
    // In a distributed system, this would involve version checks and a consensus mechanism
    // to prevent conflicts and ensure the latest valid configuration is applied.
    // For simplicity, we'll apply it directly for now.
    if (event.timestamp > (this.currentConfig as any).lastConfigUpdateTime || 0) { // Simulate versioning
      this.currentConfig = { ...event.updatedConfig, lastConfigUpdateTime: event.timestamp } as VaultConfiguration;
      console.log(`[Q_Vault ConfigManager] Applied remote configuration update.`);
    } else {
      console.warn(`[Q_Vault ConfigManager] Received older configuration update, ignoring.`);
    }
  }

  private getChanges(oldObj: Record<string, any>, newObj: Record<string, any>): Record<string, any> {
    const changes: Record<string, any> = {};
    for (const key in newObj) {
      if (JSON.stringify(oldObj[key]) !== JSON.stringify(newObj[key])) {
        changes[key] = { oldValue: oldObj[key], newValue: newObj[key] };
      }
    }
    return changes;
  }
}

/**
 * Main Q_Vault Service - The orchestrator of all components.
 * This is the primary interface for interacting with the entire vault system.
 * It's the "Central Nexus" of "Project Chimera".
 */
export class VaultService {
  private configManager: VaultConfigurationManager;
  private cryptoEngine: CryptographicEngine;
  private secretStore: SecretStore;
  private keyManagementSystem: KeyManagementSystem;
  private accessControlManager: AccessControlManager;
  private auditLogger: AuditLogger;
  private replicationCoordinator: ReplicationCoordinator;
  private backupRestoreService: BackupRestoreService;
  private dynamicSecretManager: DynamicSecretManager;
  private authenticationManager: AuthenticationManager;
  private rateLimiter: RateLimiter;
  private geminiAI: GeminiAIThreatPrediction;
  private chatGPT: ChatGPTConversationalAssistant;
  private nlpPolicyGenerator: NLPSecurityPolicyGenerator;
  private eventBus: EventBus;
  private pqcModule: PostQuantumEncryptionModule;

  private VAULT_VERSION = '7.1.2';
  private VAULT_ID: string;

  /**
   * Constructs the full Q_Vault Service.
   * @param initialConfig The initial configuration for the vault.
   * @param vaultId A unique identifier for this specific vault instance/cluster.
   * @param chatGptApiKey OpenAI API key for ChatGPT integration.
   * @param geminiApiKey Google Gemini API key for Gemini integration.
   * @param backupStorageEndpoint Endpoint for backup storage (e.g., S3 bucket URL).
   * @param quantumRNGServiceEndpoint Endpoint for a Quantum Random Number Generator service.
   * @param eventBusEndpoint Endpoint for the distributed Event Bus (e.g., Kafka).
   */
  constructor(
    initialConfig: VaultConfiguration,
    vaultId: string,
    chatGptApiKey: string,
    geminiApiKey: string,
    backupStorageEndpoint: string,
    quantumRNGServiceEndpoint: string,
    eventBusEndpoint: string
  ) {
    this.VAULT_ID = vaultId;

    // Core infrastructure services (order matters for dependencies)
    this.eventBus = new EventBus(eventBusEndpoint);
    this.configManager = new VaultConfigurationManager(initialConfig, {} as any, {} as any, this.eventBus); // Temporarily pass empty objects for circular dependency, will re-init.

    // Initialize AI Services
    this.geminiAI = new GeminiAIThreatPrediction(geminiApiKey);
    this.chatGPT = new ChatGPTConversationalAssistant(chatGptApiKey);
    this.nlpPolicyGenerator = new NLPSecurityPolicyGenerator(this.chatGPT, this.geminiAI);

    // Initialize Post-Quantum Cryptography Module
    this.pqcModule = new PostQuantumEncryptionModule(initialConfig.postQuantumCryptoEnabled, quantumRNGServiceEndpoint);

    // Initialize Cryptographic Engine (depends on PQC module)
    // We need a dummy KMS provider for CryptographicEngine construction.
    // In a real system, the default_symmetric_key would be managed internally or by a base KMS.
    // For now, let's create a minimal mock for the crypto engine.
    const mockKMSProvider: IKMSProvider = {
      providerName: 'MockInternalKMS',
      initialize: async () => {},
      generateKey: async (spec) => ({
        keyId: 'default_symmetric_key', alias: 'Default Symmetric Encryption Key', type: 'SYMMETRIC', algorithm: 'AES-256-GCM',
        creationDate: Date.now(), isEnabled: true, exportable: false, usage: 'ENCRYPTION'
      }),
      encrypt: async (keyId, plaintext) => `ENCRYPTED_WITH_${keyId}_${Buffer.from(plaintext).toString('base64')}`,
      decrypt: async (keyId, ciphertext) => Buffer.from(ciphertext.split('_')[3], 'base64').toString('utf8'), // Simple mock decryption
      sign: async (keyId, data) => `SIGNED_BY_${keyId}_${data.substring(0, 10)}_...`,
      verify: async (keyId, data, signature) => true,
      rotateKey: async (keyId) => ({
        keyId: `${keyId}_rotated_${Date.now()}`, alias: 'Rotated Key', type: 'SYMMETRIC', algorithm: 'AES-256-GCM',
        creationDate: Date.now(), isEnabled: true, exportable: false, usage: 'ENCRYPTION'
      }),
      getKeyDetails: async (keyId) => ({
        keyId: keyId, alias: keyId, type: 'SYMMETRIC', algorithm: 'AES-256-GCM',
        creationDate: Date.now(), isEnabled: true, exportable: false, usage: 'ENCRYPTION'
      }),
    };
    this.cryptoEngine = new CryptographicEngine(mockKMSProvider, this.pqcModule);

    // Re-initialize config manager with actual cryptoEngine for signing audit logs etc.
    this.configManager = new VaultConfigurationManager(initialConfig, this.cryptoEngine, this.auditLogger, this.eventBus);

    // Instantiate other core services
    this.auditLogger = new AuditLogger(this.cryptoEngine, this.eventBus, initialConfig);
    this.keyManagementSystem = new KeyManagementSystem(this.cryptoEngine, this.auditLogger, initialConfig);
    this.secretStore = new SecretStore(this.replicationCoordinator, this.cryptoEngine, this.auditLogger, this.VAULT_ID); // Needs ReplicationCoordinator, which is below
    this.accessControlManager = new AccessControlManager(this.cryptoEngine, this.auditLogger, this.nlpPolicyGenerator);
    this.replicationCoordinator = new ReplicationCoordinator(initialConfig, this.eventBus, this.cryptoEngine, this.VAULT_ID);
    this.backupRestoreService = new BackupRestoreService(this.secretStore, this.cryptoEngine, this.auditLogger, initialConfig, backupStorageEndpoint);
    this.dynamicSecretManager = new DynamicSecretManager(this.secretStore, this.cryptoEngine, this.auditLogger);
    this.authenticationManager = new AuthenticationManager(this.cryptoEngine, this.auditLogger, initialConfig);
    this.rateLimiter = new RateLimiter(); // Independent

    // Fix circular dependencies by re-assigning after all are constructed
    (this.secretStore as any).replicationCoordinator = this.replicationCoordinator; // Re-assign
    (this.configManager as any).auditLogger = this.auditLogger;
    (this.configManager as any).cryptoEngine = this.cryptoEngine;

    console.log(`[Q_Vault Core] Initialized Q_Vault v${this.VAULT_VERSION} (ID: ${this.VAULT_ID}).`);
    console.log(`[Q_Vault Core] AI Integration: Gemini ${initialConfig.aiIntegrationConfig?.geminiEnabled}, ChatGPT ${initialConfig.aiIntegrationConfig?.chatGptEnabled}.`);

    // Invention: "Self-Healing Probes" - periodic health checks of all internal modules.
    setInterval(() => this.runHealthChecks(), 5 * 60 * 1000); // Every 5 minutes

    // Invention: "Automated Compliance Scanner" - scans for policy violations or non-compliance (PCI-DSS, HIPAA, etc.)
    setInterval(() => this.runComplianceScan(), 60 * 60 * 1000); // Every hour
  }

  /**
   * Initializes all internal and external services.
   * This is called once the VaultService is constructed.
   */
  public async startup(): Promise<void> {
    console.log(`[Q_Vault Core] Starting up all services...`);
    await this.eventBus.connect();
    // Initialize external KMS providers (if any) - these are within KMS class itself.
    // Initialize AI services (if needed, constructor might be enough)
    await this.geminiAI.initialize(this.configManager.getConfiguration().aiIntegrationConfig);
    await this.chatGPT.initialize(this.configManager.getConfiguration().aiIntegrationConfig);
    console.log(`[Q_Vault Core] All services initialized and connected.`);
  }

  /**
   * Shuts down all internal services.
   */
  public async shutdown(): Promise<void> {
    console.log(`[Q_Vault Core] Shutting down all services...`);
    await this.eventBus.disconnect();
    this.dynamicSecretManager.shutdown();
    // Clear any in-memory caches or close connections if necessary.
    console.log(`[Q_Vault Core] All services shut down.`);
  }

  /**
   * Retrieves a secret, performing all necessary authorization and decryption.
   * This is a fundamental feature, the "Retrieval Conduit".
   * @param secretId The ID of the secret.
   * @param sessionId The session token of the requesting user.
   * @returns The decrypted plaintext secret.
   */
  public async getSecret(secretId: SecretId, sessionId: Token, requestingIp: IPAddress): Promise<Plaintext> {
    if (!this.rateLimiter.isAllowed(sessionId, `/secrets/${secretId}`, 'default')) {
      throw new Error('Rate limit exceeded for secret retrieval.');
    }

    const session = await this.authenticationManager.validateSession(sessionId);
    if (!session) throw new Error('Unauthorized: Invalid or expired session.');

    const encryptedSecret = await this.secretStore.getSecret(secretId);
    if (!encryptedSecret) throw new Error(`Secret ${secretId} not found.`);

    // Check access control
    const roles = await this.authenticationManager.getUserRoles(session.userId);
    const hasPermission = await this.accessControlManager.checkPermission(
      session.userId,
      roles,
      encryptedSecret.path,
      'read',
      { ipAddress: requestingIp }
    );
    if (!hasPermission) throw new Error('Forbidden: Insufficient permissions to read secret.');

    // Decrypt the secret
    const plaintext = await this.cryptoEngine.decrypt(encryptedSecret.value, undefined, this.configManager.getConfiguration().postQuantumCryptoEnabled);

    // Update metadata on access
    await this.secretStore.updateSecretMetadata(secretId, {
      lastAccessedBy: session.userId,
      lastAccessedAt: Date.now(),
    }, session.userId);

    console.log(`[Q_Vault API] User ${session.userId} retrieved secret ${secretId}.`);
    return plaintext;
  }

  /**
   * Stores a new secret or updates an existing one.
   * The "Ingestion Gateway".
   * @param secretPath The hierarchical path for the secret.
   * @param secretType The type of secret.
   * @param plaintextValue The plaintext value of the secret.
   * @param sessionId The session token of the requesting user.
   * @param requestingIp The IP address of the client.
   * @param metadata Optional metadata.
   * @returns The ID of the stored secret.
   */
  public async putSecret(
    secretPath: VaultPath,
    secretType: SecretType,
    plaintextValue: Plaintext,
    sessionId: Token,
    requestingIp: IPAddress,
    metadata?: Partial<SecretMetadata>
  ): Promise<SecretId> {
    if (!this.rateLimiter.isAllowed(sessionId, `/secrets/${secretPath}`, 'default')) {
      throw new Error('Rate limit exceeded for secret storage.');
    }

    const session = await this.authenticationManager.validateSession(sessionId);
    if (!session) throw new Error('Unauthorized: Invalid or expired session.');

    const roles = await this.authenticationManager.getUserRoles(session.userId);
    const hasPermission = await this.accessControlManager.checkPermission(
      session.userId,
      roles,
      secretPath,
      'write',
      { ipAddress: requestingIp }
    );
    if (!hasPermission) throw new Error('Forbidden: Insufficient permissions to write secret.');

    // Encrypt the secret value
    const config = await this.configManager.getConfiguration();
    const ciphertext = await this.cryptoEngine.encrypt(plaintextValue, undefined, config.postQuantumCryptoEnabled);

    const secretId = `secret_${this.cryptoEngine.generateSecureRandom(16)}`;
    const newSecret: VaultSecret = {
      id: secretId,
      path: secretPath,
      type: secretType,
      value: ciphertext,
      metadata: {
        createdAt: Date.now(),
        updatedAt: Date.now(),
        createdBy: session.userId,
        version: 1,
        tags: [],
        isDynamic: false,
        requiresRotation: false,
        ...metadata,
      },
    };

    await this.secretStore.putSecret(newSecret, session.userId);
    console.log(`[Q_Vault API] User ${session.userId} stored secret ${secretId} at ${secretPath}.`);
    return secretId;
  }

  /**
   * Deletes a secret.
   * The "Sanitization Executor".
   * @param secretId The ID of the secret to delete.
   * @param sessionId The session token of the requesting user.
   * @param requestingIp The IP address of the client.
   * @returns True if deleted, false if not found.
   */
  public async deleteSecret(secretId: SecretId, sessionId: Token, requestingIp: IPAddress): Promise<boolean> {
    if (!this.rateLimiter.isAllowed(sessionId, `/secrets/${secretId}`, 'default')) {
      throw new Error('Rate limit exceeded for secret deletion.');
    }

    const session = await this.authenticationManager.validateSession(sessionId);
    if (!session) throw new Error('Unauthorized: Invalid or expired session.');

    const secret = await this.secretStore.getSecret(secretId);
    if (!secret) return false; // Already gone or never existed

    const roles = await this.authenticationManager.getUserRoles(session.userId);
    const hasPermission = await this.accessControlManager.checkPermission(
      session.userId,
      roles,
      secret.path,
      'delete',
      { ipAddress: requestingIp }
    );
    if (!hasPermission) throw new Error('Forbidden: Insufficient permissions to delete secret.');

    const deleted = await this.secretStore.deleteSecret(secretId, session.userId);
    console.log(`[Q_Vault API] User ${session.userId} deleted secret ${secretId}.`);
    return deleted;
  }

  /**
   * Rotates a secret, generating a new value and updating the vault.
   * The "Lifecycle Manager".
   * @param secretId The ID of the secret to rotate.
   * @param sessionId The session token of the requesting user.
   * @param requestingIp The IP address of the client.
   * @returns The new plaintext value of the secret (if applicable, otherwise confirmation).
   */
  public async rotateSecret(secretId: SecretId, sessionId: Token, requestingIp: IPAddress): Promise<Plaintext | string> {
    if (!this.rateLimiter.isAllowed(sessionId, `/secrets/${secretId}/rotate`, 'default')) {
      throw new Error('Rate limit exceeded for secret rotation.');
    }

    const session = await this.authenticationManager.validateSession(sessionId);
    if (!session) throw new Error('Unauthorized: Invalid or expired session.');

    const existingSecret = await this.secretStore.getSecret(secretId);
    if (!existingSecret) throw new Error(`Secret ${secretId} not found for rotation.`);

    const roles = await this.authenticationManager.getUserRoles(session.userId);
    const hasPermission = await this.accessControlManager.checkPermission(
      session.userId,
      roles,
      existingSecret.path,
      'rotate',
      { ipAddress: requestingIp }
    );
    if (!hasPermission) throw new Error('Forbidden: Insufficient permissions to rotate secret.');

    // Logic for actual secret rotation depends on its type.
    let newPlaintextValue: Plaintext = '';
    const config = await this.configManager.getConfiguration();

    switch (existingSecret.type) {
      case SecretType.API_KEY:
      case SecretType.GENERIC_VALUE:
      case SecretType.ENVIRONMENT_VARIABLE:
        newPlaintextValue = this.cryptoEngine.generateSecureRandom(48); // Generate new random value
        break;
      case SecretType.DATABASE_CREDENTIALS:
        // This is complex: requires the DynamicSecretManager to talk to the DB directly.
        // For existing secrets, this means rotating the static root credential, which isn't ideal.
        // Better: use dynamic secrets or a dedicated database rotation service.
        console.warn(`[Q_Vault API] Direct rotation of static DB credentials is not recommended. Use dynamic secrets.`);
        newPlaintextValue = this.cryptoEngine.generateSecureRandom(32); // Placeholder
        break;
      case SecretType.TLS_CERTIFICATE:
      case SecretType.SSH_KEY:
        // These need to interact with PKI or SSH CA.
        console.warn(`[Q_Vault API] Rotation of PKI/SSH secrets typically involves re-issuance through dynamic secret manager.`);
        newPlaintextValue = 'ROTATION_REQUIRES_DYNAMIC_MANAGER_REISSUE';
        break;
      default:
        throw new Error(`Secret type ${existingSecret.type} does not support direct rotation via this API.`);
    }

    const newCiphertext = await this.cryptoEngine.encrypt(newPlaintextValue, undefined, config.postQuantumCryptoEnabled);
    const updatedSecret: VaultSecret = {
      ...existingSecret,
      value: newCiphertext,
      metadata: {
        ...existingSecret.metadata,
        updatedAt: Date.now(),
        version: existingSecret.metadata.version + 1,
        nextRotationDue: Date.now() + (config.keyRotationIntervalDays[existingSecret.type] || 365) * 24 * 60 * 60 * 1000,
      },
    };
    await this.secretStore.putSecret(updatedSecret, session.userId);

    await this.auditLogger.log({
      id: this.cryptoEngine.generateSecureRandom(32),
      timestamp: Date.now(),
      eventType: AuditEventType.SECRET_ROTATE,
      actor: session.userId,
      target: secretId,
      details: { path: existingSecret.path, newVersion: updatedSecret.metadata.version },
      sourceIp: requestingIp,
      signedHash: await this.cryptoEngine.hash(secretId + session.userId + Date.now()),
    });
    console.log(`[Q_Vault API] User ${session.userId} rotated secret ${secretId}. New version: ${updatedSecret.metadata.version}.`);

    return newPlaintextValue; // Return new value for immediate use
  }

  /**
   * Exposes the configured authentication manager.
   * @returns The AuthenticationManager instance.
   */
  public getAuthenticationManager(): AuthenticationManager {
    return this.authenticationManager;
  }

  /**
   * Exposes the configured access control manager.
   * @returns The AccessControlManager instance.
   */
  public getAccessControlManager(): AccessControlManager {
    return this.accessControlManager;
  }

  /**
   * Exposes the configured dynamic secret manager.
   * @returns The DynamicSecretManager instance.
   */
  public getDynamicSecretManager(): DynamicSecretManager {
    return this.dynamicSecretManager;
  }

  /**
   * Exposes the configured audit logger.
   * @returns The AuditLogger instance.
   */
  public getAuditLogger(): AuditLogger {
    return this.auditLogger;
  }

  /**
   * Exposes the configured replication coordinator.
   * @returns The ReplicationCoordinator instance.
   */
  public getReplicationCoordinator(): ReplicationCoordinator {
    return this.replicationCoordinator;
  }

  /**
   * Exposes the configured backup/restore service.
   * @returns The BackupRestoreService instance.
   */
  public getBackupRestoreService(): BackupRestoreService {
    return this.backupRestoreService;
  }

  /**
   * Exposes the configured key management system.
   * @returns The KeyManagementSystem instance.
   */
  public getKeyManagementSystem(): KeyManagementSystem {
    return this.keyManagementSystem;
  }

  /**
   * Exposes the AI threat prediction service (Gemini).
   * @returns The GeminiAIThreatPrediction instance.
   */
  public getGeminiAIThreatPrediction(): GeminiAIThreatPrediction {
    return this.geminiAI;
  }

  /**
   * Exposes the ChatGPT conversational assistant.
   * @returns The ChatGPTConversationalAssistant instance.
   */
  public getChatGPTConversationalAssistant(): ChatGPTConversationalAssistant {
    return this.chatGPT;
  }

  /**
   * Exposes the NLP Security Policy Generator.
   * @returns The NLPSecurityPolicyGenerator instance.
   */
  public getNLPSecurityPolicyGenerator(): NLPSecurityPolicyGenerator {
    return this.nlpPolicyGenerator;
  }

  /**
   * Allows external components to register an external KMS provider.
   * @param provider The IKMSProvider implementation.
   */
  public registerKMSProvider(provider: IKMSProvider): void {
    // We access the private map for demonstration purposes.
    // In a real system, KeyManagementSystem would have a public method for this.
    (this.keyManagementSystem as any).externalKmsProviders.set(provider.providerName, provider);
    console.log(`[Q_Vault Core] Registered external KMS provider: ${provider.providerName}.`);
  }

  /**
   * Allows external components to register a database connector.
   * @param connector The IDatabaseConnector implementation.
   */
  public registerDatabaseConnector(connector: IDatabaseConnector): void {
    this.dynamicSecretManager.registerDatabaseConnector(connector);
  }

  /**
   * Allows external components to register a certificate authority.
   * @param ca The ICertificateAuthority implementation.
   */
  public registerCertificateAuthority(ca: ICertificateAuthority): void {
    this.dynamicSecretManager.registerCertificateAuthority(ca);
  }

  /**
   * Performs routine health checks across all vault components.
   * Invention: "Omni-Component Health Monitor" - uses metrics, logs, and internal APIs.
   */
  private async runHealthChecks(): Promise<void> {
    console.log(`[Q_Vault Core] Running scheduled health checks...`);
    const results: Record<string, string> = {};

    try {
      await this.eventBus.connect(); // Check event bus connectivity
      results.eventBus = 'OK';
    } catch (e) {
      results.eventBus = `ERROR: ${e.message}`;
    }

    try {
      const config = await this.configManager.getConfiguration();
      if (config.replicationEnabled) {
        const replicationStatus = await this.replicationCoordinator.getReplicationStatus();
        results.replication = replicationStatus.every(s => s.status === ReplicationStatus.IN_SYNC) ? 'OK' : 'DEGRADED';
      } else {
        results.replication = 'DISABLED';
      }
    } catch (e) {
      results.replication = `ERROR: ${e.message}`;
    }

    try {
      const integrity = await this.auditLogger.verifyAuditChainIntegrity();
      results.auditLogIntegrity = integrity ? 'OK' : 'COMPROMISED';
    } catch (e) {
      results.auditLogIntegrity = `ERROR: ${e.message}`;
    }

    // Example AI health check
    try {
      const aiConfig = this.configManager.getConfiguration().aiIntegrationConfig;
      if (aiConfig?.geminiEnabled) {
        // Ping Gemini with a simple query
        await this.geminiAI.answerSecurityQuery("Are you online?", {});
        results.geminiAI = 'OK';
      } else {
        results.geminiAI = 'DISABLED';
      }
    } catch (e) {
      results.geminiAI = `ERROR: ${e.message}`;
    }

    console.log(`[Q_Vault Core] Health check results: ${JSON.stringify(results)}`);
    // Invention: "Proactive Alerting System" - integrates with PagerDuty/Slack for critical issues.
    if (Object.values(results).some(status => status.includes('ERROR') || status.includes('COMPROMISED') || status.includes('DEGRADED'))) {
      console.error(`[Q_Vault Core] Critical health issues detected! Raising alert.`);
      // Trigger PagerDuty or other alerting.
    }
  }

  /**
   * Runs a comprehensive compliance scan against configured policies and regulations.
   * Invention: "Regulatory Compliance Auditor" - checks for GDPR, HIPAA, PCI-DSS violations.
   */
  private async runComplianceScan(): Promise<void> {
    console.log(`[Q_Vault Core] Running scheduled compliance scan...`);
    const config = await this.configManager.getConfiguration();
    if (config.complianceMode === 'NONE') {
      console.log(`[Q_Vault Core] Compliance scan skipped: complianceMode is NONE.`);
      return;
    }

    const violations: string[] = [];
    const allSecrets = await this.secretStore.listSecrets();

    // Example: PCI-DSS check for plain payment card data (should be tokenized)
    if (config.complianceMode === 'PCI_DSS') {
      console.log(`[Q_Vault Core] Performing PCI-DSS compliance checks...`);
      for (const secretId of allSecrets) {
        const secret = await this.secretStore.getSecret(secretId);
        if (secret && secret.type === SecretType.PAYMENT_CARD_DATA) {
          // Simulate deeper inspection. In a real system, value would be inspected.
          if (!secret.value.startsWith('VLT_TKN_')) { // Assuming tokenized secrets start with this prefix
            violations.push(`PCI-DSS violation: Secret ${secretId} (path: ${secret.path}) contains untokenized payment card data.`);
          }
        }
      }
    }

    // Example: GDPR check for excessive data retention
    if (config.complianceMode === 'GDPR') {
      console.log(`[Q_Vault Core] Performing GDPR compliance checks...`);
      for (const secretId of allSecrets) {
        const secret = await this.secretStore.getSecret(secretId);
        if (secret && secret.metadata.tags.includes('PII') && secret.metadata.expiresAt === undefined) {
          violations.push(`GDPR violation: PII secret ${secretId} (path: ${secret.path}) has no defined expiration date.`);
        }
      }
    }

    // Report findings
    if (violations.length > 0) {
      console.error(`[Q_Vault Core] Compliance scan detected ${violations.length} violations for ${config.complianceMode}:`);
      violations.forEach(v => console.error(`  - ${v}`));
      await this.auditLogger.log({
        id: this.cryptoEngine.generateSecureRandom(32),
        timestamp: Date.now(),
        eventType: AuditEventType.AI_ANOMALY_DETECTED, // Re-use for compliance finding
        actor: 'system_compliance_scanner',
        target: 'vault_compliance',
        details: { complianceMode: config.complianceMode, violations },
        sourceIp: 'N/A',
        signedHash: await this.cryptoEngine.hash(JSON.stringify(violations) + config.complianceMode + Date.now()),
      });
      // Optionally, trigger automated remediation workflows or critical alerts.
    } else {
      console.log(`[Q_Vault Core] Compliance scan for ${config.complianceMode} completed with no violations.`);
    }
  }

  /**
   * Provides access to the raw internal SecretStore for administrative tasks.
   * This is a highly privileged operation.
   * @returns The raw SecretStore instance.
   */
  public _getRawSecretStore(): SecretStore {
    console.warn(`[Q_Vault API] Accessing raw SecretStore. This is for advanced administrative and debugging purposes only.`);
    return this.secretStore;
  }

  /**
   * Provides access to the raw internal ConfigurationManager.
   * @returns The raw ConfigurationManager instance.
   */
  public _getRawConfigManager(): VaultConfigurationManager {
    console.warn(`[Q_Vault API] Accessing raw ConfigurationManager.`);
    return this.configManager;
  }
}

// Export the main VaultService and all auxiliary types/classes
export default VaultService; // Main entry point

// Also export all the types, enums, and individual services for modularity and testing.
export {
  SecretType,
  AuthMethod,
  PolicyEffect,
  AuditEventType,
  ReplicationStatus,
  type SecretId,
  type PolicyId,
  type AuditLogId,
  type UserId,
  type RoleId,
  type Token,
  type VaultPath,
  type Ciphertext,
  type Plaintext,
  type PublicKey,
  type PrivateKey,
  type Certificate,
  type Hash,
  type Timestamp,
  type IPAddress,
  type GeoLocation,
  type SecretMetadata,
  type VaultSecret,
  type VaultPolicy,
  type PolicyRule,
  type PolicyCondition,
  type AuditLogEntry,
  type VaultConfiguration,
  type ReplicationEvent,
  type BackupManifest,
  type EncryptionKeyDetails,
  type SessionToken,
  type DatabaseCredentialLease,
  type SSHKeyLease,
  type CertificateLease,
  type IKMSProvider,
  type IAIModelService,
  type IIdentityProvider,
  type ICertificateAuthority,
  type IDatabaseConnector,
  CryptographicEngine,
  PostQuantumEncryptionModule,
  EventBus,
  RateLimiter,
  SecretStore,
  KeyManagementSystem,
  AccessControlManager,
  AuditLogger,
  ReplicationCoordinator,
  BackupRestoreService,
  GeminiAIThreatPrediction,
  ChatGPTConversationalAssistant,
  NLPSecurityPolicyGenerator,
  DynamicSecretManager,
  AuthenticationManager,
  VaultConfigurationManager,
};
